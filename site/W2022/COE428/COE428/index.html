
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="A collection of notes I made for the courses I've taken in Ryerson University">
      
      
        <meta name="author" content="Jasper Cruz">
      
      
        <link rel="canonical" href="https://jsprcrz.github.io/Notes/W2022/COE428/COE428/">
      
      <link rel="icon" href="../../../assets/favicon.png">
      <meta name="generator" content="mkdocs-1.3.0, mkdocs-material-8.2.9">
    
    
      
        <title>COE428 - Notes</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/main.120efc48.min.css">
      
        
        <link rel="stylesheet" href="../../../assets/stylesheets/palette.9647289d.min.css">
        
          
          
          <meta name="theme-color" content="#000000">
        
      
    
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../../../css/katex.css">
    
      <link rel="stylesheet" href="../../../css/custom.css">
    
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
    
    <script>__md_scope=new URL("../../..",location),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      
  


  
  


  <script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-SR44P16LQ4"),document.addEventListener("DOMContentLoaded",function(){document.forms.search&&document.forms.search.query.addEventListener("blur",function(){this.value&&gtag("event","search",{search_term:this.value})}),"undefined"!=typeof location$&&location$.subscribe(function(e){gtag("config","G-SR44P16LQ4",{page_path:e.pathname})})})</script>
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-SR44P16LQ4"></script>


    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="" data-md-color-primary="black" data-md-color-accent="black">
  
    
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#introduction-to-algorithms" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../../.." title="Notes" class="md-header__button md-logo" aria-label="Notes" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="m19 2-5 4.5v11l5-4.5V2M6.5 5C4.55 5 2.45 5.4 1 6.5v14.66c0 .25.25.5.5.5.1 0 .15-.07.25-.07 1.35-.65 3.3-1.09 4.75-1.09 1.95 0 4.05.4 5.5 1.5 1.35-.85 3.8-1.5 5.5-1.5 1.65 0 3.35.31 4.75 1.06.1.05.15.03.25.03.25 0 .5-.25.5-.5V6.5c-.6-.45-1.25-.75-2-1V19c-1.1-.35-2.3-.5-3.5-.5-1.7 0-4.15.65-5.5 1.5V6.5C10.55 5.4 8.45 5 6.5 5Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Notes
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              COE428
            
          </span>
        </div>
      </div>
    </div>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" aria-label="Clear" tabindex="-1">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
        <div class="md-search__suggest" data-md-component="search-suggest"></div>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/jsprcrz/Notes" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.1.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg>
  </div>
  <div class="md-source__repository">
    jsprcrz/Notes
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../.." title="Notes" class="md-nav__button md-logo" aria-label="Notes" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="m19 2-5 4.5v11l5-4.5V2M6.5 5C4.55 5 2.45 5.4 1 6.5v14.66c0 .25.25.5.5.5.1 0 .15-.07.25-.07 1.35-.65 3.3-1.09 4.75-1.09 1.95 0 4.05.4 5.5 1.5 1.35-.85 3.8-1.5 5.5-1.5 1.65 0 3.35.31 4.75 1.06.1.05.15.03.25.03.25 0 .5-.25.5-.5V6.5c-.6-.45-1.25-.75-2-1V19c-1.1-.35-2.3-.5-3.5-.5-1.7 0-4.15.65-5.5 1.5V6.5C10.55 5.4 8.45 5 6.5 5Z"/></svg>

    </a>
    Notes
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/jsprcrz/Notes" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.1.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg>
  </div>
  <div class="md-source__repository">
    jsprcrz/Notes
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../.." class="md-nav__link">
        Preface
      </a>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_2" type="checkbox" id="__nav_2" >
      
      
      
      
        <label class="md-nav__link" for="__nav_2">
          PDF
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="PDF" data-md-level="1">
        <label class="md-nav__title" for="__nav_2">
          <span class="md-nav__icon md-icon"></span>
          PDF
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../Term/W2022/" class="md-nav__link">
        Winter 2022
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../Term/F2021/" class="md-nav__link">
        Fall 2021
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../Term/W2021/" class="md-nav__link">
        Winter 2021
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
    
  
  
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_3" type="checkbox" id="__nav_3" checked>
      
      
      
      
        <label class="md-nav__link" for="__nav_3">
          Notes (WIP)
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Notes (WIP)" data-md-level="1">
        <label class="md-nav__title" for="__nav_3">
          <span class="md-nav__icon md-icon"></span>
          Notes (WIP)
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
    
  
  
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_3_1" type="checkbox" id="__nav_3_1" checked>
      
      
      
      
        <label class="md-nav__link" for="__nav_3_1">
          Winter 2022
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Winter 2022" data-md-level="2">
        <label class="md-nav__title" for="__nav_3_1">
          <span class="md-nav__icon md-icon"></span>
          Winter 2022
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" data-md-toggle="toc" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          COE428
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        COE428
      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#algorithm-analysis" class="md-nav__link">
    Algorithm Analysis
  </a>
  
    <nav class="md-nav" aria-label="Algorithm Analysis">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#running-time" class="md-nav__link">
    Running Time
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#classes-of-functions" class="md-nav__link">
    Classes of Functions
  </a>
  
    <nav class="md-nav" aria-label="Classes of Functions">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#growth-rate-of-running-time" class="md-nav__link">
    Growth Rate of Running Time
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../MTH314/MTH314/" class="md-nav__link">
        MTH314
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../ELE404/ELE404/" class="md-nav__link">
        ELE404
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#algorithm-analysis" class="md-nav__link">
    Algorithm Analysis
  </a>
  
    <nav class="md-nav" aria-label="Algorithm Analysis">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#running-time" class="md-nav__link">
    Running Time
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#classes-of-functions" class="md-nav__link">
    Classes of Functions
  </a>
  
    <nav class="md-nav" aria-label="Classes of Functions">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#growth-rate-of-running-time" class="md-nav__link">
    Growth Rate of Running Time
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content" data-md-component="content">
            <article class="md-content__inner md-typeset">
              
                
  <a href="https://github.com/jsprcrz/Notes/edit/master/docs/W2022/COE428/COE428.md" title="Edit this page" class="md-content__button md-icon">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20.71 7.04c.39-.39.39-1.04 0-1.41l-2.34-2.34c-.37-.39-1.02-.39-1.41 0l-1.84 1.83 3.75 3.75M3 17.25V21h3.75L17.81 9.93l-3.75-3.75L3 17.25Z"/></svg>
  </a>


  



<details class="introduction">
<summary>Introduction</summary>
<p>This will cover various topics for the course COE428: Algorithms and Data Structures, using the textbook, <em>Introduction to  Algorithms</em>, by T. Cormen, C. Leiserson, R. Rive, and lectures notes provided by the professor, Dr. Reza Samavi.</p>
<p>Other resources used:</p>
<ul>
<li><a href="https://www.youtube.com/playlist?list=PLDN4rrl48XKpZkf03iYFl-O29szjTrs_O">Abdul Bari - Algorithms</a></li>
</ul>
</details>
<div align="center">
  <img src = "https://img.shields.io/badge/Winter-2022-blue">
  <img src = "https://img.shields.io/badge/Ryerson-University-yellow">
</div>

<p>Last Updated: 2022-04-16</p>
<h1 id="introduction-to-algorithms">Introduction to Algorithms<a class="headerlink" href="#introduction-to-algorithms" title="Permanent link">&para;</a></h1>
<h2 id="algorithm-analysis">Algorithm Analysis<a class="headerlink" href="#algorithm-analysis" title="Permanent link">&para;</a></h2>
<p>An algorithm is a sequence of computational step that transform the input into the output. You will typically see them displayed as pseudocode shown below:</p>
<!-- ::: algorithm
::: algorithmic
$key = A[j]$ $i = j - 1$ $A[i+1] = A[i]$ $i = i - 1$ $A[i+1] = key$
:::
::: -->

<p>It is very convenient to classify algorithms based on the relative amount of time or relative amount of space they require and specify as a function of the input size. Thus, we have the notions of:</p>
<ul>
<li>Time Complexity: Running time of the program as a function of the size of input.</li>
<li>Space Complexity: Amount of computer memory required during the program execution, as a function of the input size.</li>
</ul>
<h3 id="running-time">Running Time<a class="headerlink" href="#running-time" title="Permanent link">&para;</a></h3>
<p>The time complexity of an algorithm can be measured by characterizing running time as a function, <span class="arithmatex">\(T(n)\)</span>, of the input size, <span class="arithmatex">\(n\)</span>. We count the number of primitive operations that are executed:</p>
<ul>
<li>
<p>Assigning a value to a variable</p>
</li>
<li>
<p>Calling a method</p>
</li>
<li>
<p>Performing an arithmetic operation</p>
</li>
<li>
<p>Comparing two values</p>
</li>
<li>
<p>Indexing into an array</p>
</li>
<li>
<p>Returning from a method</p>
</li>
</ul>
<p>::: algorithm
::: algorithmic
<span class="arithmatex">\(temp = a\)</span>;</p>
<p><span class="arithmatex">\(a = b\)</span>;</p>
<p><span class="arithmatex">\(b = temp\)</span>;
:::
:::</p>
<p>For this example, we say the running time is <span class="arithmatex">\(T(n) = 3\)</span>,
since there's three primitive operations executed by an algorithm. When
it comes to loops, it becomes a bit more complex.</p>
<p>::: algorithm
::: algorithmic
<span class="arithmatex">\(x = s[0]\)</span> <span class="arithmatex">\(x = s[i]\)</span>
:::
:::</p>
<p>We define the size of the input array to be <span class="arithmatex">\(n\)</span>:</p>
<ol>
<li>
<p>In line 1, its indexing an array, <span class="arithmatex">\(s[0]\)</span>, then
    assigning it to <span class="arithmatex">\(x\)</span></p>
</li>
<li>
<p>In line 2, inside the for loop:</p>
<ul>
<li>
<p>It first assigns <span class="arithmatex">\(i = 1\)</span></p>
</li>
<li>
<p>On each iteration, it makes a comparison, <span class="arithmatex">\(&lt;\)</span>, for
    <span class="arithmatex">\(n\)</span> times</p>
</li>
</ul>
</li>
<li>
<p>In line 3, the if statement repeats for :</p>
<ul>
<li>
<p>Its indexing an array, <span class="arithmatex">\(s[i]\)</span>, then makes a
    comparison, <span class="arithmatex">\(&gt;\)</span></p>
</li>
<li>
<p>In line 4, there's two possibilities that could occur:</p>
<ul>
<li>
<p>If true, then its indexing an array, <span class="arithmatex">\(s[i]\)</span>,
    then assigning it to <span class="arithmatex">\(x\)</span></p>
</li>
<li>
<p>If false, then it won't execute</p>
</li>
</ul>
</li>
<li>
<p>At the end, <span class="arithmatex">\(i++\)</span>, is incremented, then assigned
    back to <span class="arithmatex">\(i\)</span></p>
</li>
</ul>
</li>
<li>
<p>The last line returns <span class="arithmatex">\(x\)</span></p>
</li>
</ol>
<p>The number of primitive operations executed by algorithm can be
characterized in two ways:</p>
<ul>
<li>
<p>Best-Case Analysis:
    <span class="arithmatex">\(T(n) = 2 + 1 + n + (n-1)(2 + 0 + 2) + 1 = 5n\)</span></p>
</li>
<li>
<p>Worst-Case Analysis:
    <span class="arithmatex">\(T(n) = 2 + 1 + n + (n-1)(2 + 2 + 2) + 1 = 7n - 2\)</span></p>
</li>
</ul>
<p>... to which it is bounded by two linear functions,
<span class="arithmatex">\(5n \leq T(n) \leq 7n - 2\)</span></p>
<h2 id="classes-of-functions">Classes of Functions<a class="headerlink" href="#classes-of-functions" title="Permanent link">&para;</a></h2>
<p>Let's first go over some common functions that characterize the running time of an algorithm:</p>
<ul>
<li>
<p>Constant function: <span class="arithmatex">\(f(n)  = c\)</span></p>
</li>
<li>
<p>Linear function: <span class="arithmatex">\(f(n) = n\)</span></p>
</li>
<li>
<p>n-log-n function: <span class="arithmatex">\(f(n) = n\log{n}\)</span></p>
</li>
<li>
<p>Quadratic function: <span class="arithmatex">\(f(n) = n^2\)</span></p>
</li>
<li>
<p>Cubic function: <span class="arithmatex">\(f(n) = n^3\)</span></p>
</li>
<li>
<p>Exponents: <span class="arithmatex">\(f(n) = b^n\)</span></p>
</li>
<li>
<p>Logarithms: <span class="arithmatex">\(f(n) = \log_2{n}\)</span></p>
</li>
</ul>
<p>A review from MTH is the summation formula, which will be useful when analyzing the time complexity of algorithms:</p>
<ul>
<li>
<p>Arithmetic series:
    <span class="arithmatex">\(\displaystyle\sum_{k = 0}^{n} k = 1 + 2 + \cdots + n = \frac{n(n+1)}{2}\)</span></p>
</li>
<li>
<p>Geometric series:
    <span class="arithmatex">\(\displaystyle\sum_{k = 0}^{n} x^k = 1 + x + x^2 + \cdots + x^n = \frac{1-x^{n+1}}{1-x}\)</span></p>
</li>
</ul>
<p>... and the following terms which you might recall from coding:</p>
<ul>
<li>
<p><span class="arithmatex">\(\lfloor x \rfloor\)</span> or <code>floor(x)</code> is largest integer
    less than to equal to <span class="arithmatex">\(x\)</span>.</p>
</li>
<li>
<p><span class="arithmatex">\(\lceil x \rceil\)</span> or<code>ceiling(x)</code> is least integer
    greater than to equal to <span class="arithmatex">\(x\)</span>.</p>
</li>
</ul>
<h3 id="growth-rate-of-running-time">Growth Rate of Running Time<a class="headerlink" href="#growth-rate-of-running-time" title="Permanent link">&para;</a></h3>
<p>When choosing between algorithms, we care most about asymptotic performance; how the algorithm increases with the input size.</p>
<p>::: center
<img alt="image" src="../Figure/1/growth_rate.png" width="60%" />
:::</p>
<p>If you notice, as the input size increases, certain class of functions grows much more rapidly than others.</p>
<p>::: center
<img alt="image" src="../Figure/1/growth_num.png" width="75%" />
:::</p>
<p>If we let the value of the growth-rate function represent the units of time, an algorithm with the function <span class="arithmatex">\(f(n) = \log_2{n}\)</span> would be much more efficient than an algorithm with the function <span class="arithmatex">\(f(n) = 2^n\)</span>.</p>
<p>In general, the order-of-growth can be classified to be:
<span class="arithmatex">\(<span class="arithmatex">\(1 &lt; \log{n} &lt; \sqrt{n} &lt; n &lt; n\log{n} &lt; n^2 &lt; n^3 &lt; \cdots &lt; 2^n &lt; 3^n &lt; \cdots &lt; n! &lt; n^n\)</span>\)</span></p>
<h1 id="analyzing-and-designing-algorithms">Analyzing and Designing Algorithms<a class="headerlink" href="#analyzing-and-designing-algorithms" title="Permanent link">&para;</a></h1>
<p>In this lecture, we will go over three different types of sorting
algorithm: insertion sort, merge sort, and selection sort.</p>
<p>The purpose of sorting algorithms is to solve the following problem:</p>
<dl>
<dt>Input:</dt>
<dd>
<p>A sequence of <span class="arithmatex">\(n\)</span> numbers
<span class="arithmatex">\(\langle a_1, a_2, \dots, a_n \rangle\)</span></p>
</dd>
<dt>Output:</dt>
<dd>
<p>A permutation (reordering)
<span class="arithmatex">\(\langle a'_1, a'_2, \dots, a'_n \rangle\)</span> of the input
sequence such that
<span class="arithmatex">\(a'_1 \leq a'_2 \leq \dots \leq a'_n\)</span>.</p>
</dd>
</dl>
<p>::: dBox
::: definitionT
<strong>Definition 2.1</strong> (Key). <em>The sequence are typically stored in array.
We also refer to the number as keys.</em>
:::
:::</p>
<h2 id="insertion-sort">Insertion Sort<a class="headerlink" href="#insertion-sort" title="Permanent link">&para;</a></h2>
<p>Insertion sort is a sorting
algorithm that places an unsorted element at its suitable place in each
iteration.</p>
<p>::: algorithm
[Insertion-Sort<span class="arithmatex">\((A,n) \to A[1 \dots\ n]\)</span>]{.smallcaps}</p>
<p>::: algorithmic
<span class="arithmatex">\(key = A[j]\)</span> <span class="arithmatex">\(i = j - 1\)</span> <span class="arithmatex">\(A[i+1] = A[i]\)</span> <span class="arithmatex">\(i = i - 1\)</span> <span class="arithmatex">\(A[i+1] = key\)</span>
:::
:::</p>
<ol>
<li>
<p>Iterate from [<code>A[1]</code>]{style="background-color: light-gray"} to
    [<code>A[n]</code>]{style="background-color: light-gray"} over the array.</p>
</li>
<li>
<p>Compare the current element
    [<code>key = A[j]</code>]{style="background-color: light-gray"} to its
    predecessor.</p>
</li>
<li>
<p>If the element is smaller than its predecessor, compare it to the
    elements before. Move the greater elements one position up to make
    space for the swapped element.</p>
</li>
</ol>
<p>::: list</p>
<p>Note that iterations starts at
[<code>A[1]</code>]{style="background-color: light-gray"}, not
[<code>A[0]</code>]{style="background-color: light-gray"}. For the sake of
convenience, we assume a fictitious record
[<code>A[0]</code>]{style="background-color: light-gray"} as the sentinel value
with key of <span class="arithmatex">\(-\infty\)</span>.
:::</p>
<p>It maybe easier to visualize this using images to better understand the psuedocode written. Suppose we start out with the following array with 6 elements.</p>
<p>::: center
<img alt="image" src="../Figure/2/insertion_arr.png" width="45%" />
:::</p>
<p>If we apply the insertion sort algorithm, the following array would be sorted as shown below. Let's denote the [<code>key</code>]{style="background-color: light-gray"} in green.</p>
<p>::: center
<img alt="image" src="../Figure/2/insertion_sort.png" width="48%" />
:::</p>
<p>Since we care most about the asymptotic performance, we are interested on finding the running time <span class="arithmatex">\(T(n)\)</span>.</p>
<p>::: algorithm
::: algorithmic
<span class="arithmatex">\(key = A[j]\)</span></p>
<p><span class="arithmatex">\(i = j - 1\)</span></p>
<p><span class="arithmatex">\(A[i+1] = A[i]\)</span></p>
<p><span class="arithmatex">\(i = i - 1\)</span></p>
<p><span class="arithmatex">\(A[i+1] = key\)</span>
:::
:::</p>
<p>The lectures note and textbook goes in-depth deriving the following
running time of insertion sort:
<span class="arithmatex">\(<span class="arithmatex">\(T(n) = c_1n + c_2(n - 1) + c_4(n - 1) + c_5\sum_{j = 2}^n t_j + c_6\sum_{j = 2}^n (t_j - 1)  + c_7\sum_{j = 2}^n (t_j - 1) + c_8(n - 1)\)</span>\)</span>
where <span class="arithmatex">\(t_j\)</span> is the number of times the while loop is
executed for that value of <span class="arithmatex">\(j\)</span>.</p>
<p>The main takeaway is knowing how it sorts and the function for best and
worst-case running time of the following algorithm is. In the next
lecture, we will go more in-depth on analyzing the time complexity using
asymptotic notations, which simplifies all of this stuff.</p>
<h3 id="best-case-complexity">Best-Case Complexity<a class="headerlink" href="#best-case-complexity" title="Permanent link">&para;</a></h3>
<p>The best-case scenario
is when the array is already sorted.</p>
<p>::: center
<img alt="image" src="../Figure/2/ex_insertion1.png" width="45%" />
:::</p>
<p>In this example, the while loop does the comparison but never enters the
loop, since it always find that
[<code>A[i]</code>]{style="background-color: light-gray"} is always less than or
equal to [<code>key</code>]{style="background-color: light-gray"}.</p>
<p>::: center
<img alt="image" src="../Figure/2/ex_insertion1a.png" width="65%" />
:::</p>
<p>Thus, <span class="arithmatex">\(t_j = 1\)</span>, we can derive the number of comparisons
for every outer loop iteration:
<span class="arithmatex">\(<span class="arithmatex">\(\sum_{j=2}^n t_j \to \sum_{j=2}^n 1 = (n - 2) + 1 = n - 1\)</span>\)</span>
Substituting this in the equation to the running time simplifies
<span class="arithmatex">\(T(n)\)</span> to <span class="arithmatex">\(<span class="arithmatex">\({
    \begin{split}
         T(n) &amp;= c_1n + c_2(n - 1) + c_4(n - 1) + c_5(n - 1) + c_8(n - 1) \\
             &amp;= (c_1 + c_2 + c_4 + c_5 + c_8)n - (c_2 + c_4 + 5 + c_8)
    \end{split}}\)</span>\)</span> or equivalently, if we let <span class="arithmatex">\(c_n\)</span>
simplify to some constants <span class="arithmatex">\(a\)</span> and <span class="arithmatex">\(b\)</span> then
<span class="arithmatex">\(<span class="arithmatex">\(T(n) = an - b\)</span>\)</span></p>
<h3 id="worst-case-complexity">Worst-Case Complexity<a class="headerlink" href="#worst-case-complexity" title="Permanent link">&para;</a></h3>
<p>The worst-case scenario is when the array is sorted in reversefrom largest to smallest.</p>
<p>::: center
<img alt="image" src="../Figure/2/ex_insertion2.png" width="45%" />
:::</p>
<p>In this example, <span class="arithmatex">\(t_j\)</span> has to compare with all elements to
the left <span class="arithmatex">\(j\)</span>-th positioncompare with <span class="arithmatex">\(j - 1\)</span>
elements.</p>
<p>Thus, <span class="arithmatex">\(t_j = j\)</span>, we can derive the number of comparisons
for every outer loop iteration
<span class="arithmatex">\(<span class="arithmatex">\(\sum_{j = 2}^{n} t_j \to \sum_{j = 2}^{n} j = 2 + 3 + 4 + \dots + n = \bigg[\sum_{j=1}^n j\bigg] - 1 = \frac{n(n+1)}{2} - 1\)</span>\)</span>
and as well the number of moves inside the while loop:
<span class="arithmatex">\(<span class="arithmatex">\(\sum_{j = 2}^{n} (t_j - 1) \to \sum_{j = 2}^{n} (j - 1) = 1 + 2 + 3 + \dots + n - 1 = \frac{n(n-1)}{2}\)</span>\)</span>
Substituting this in the equation to the running time simplifies
<span class="arithmatex">\(T(n)\)</span> to <span class="arithmatex">\(<span class="arithmatex">\({
    \begin{split}
         T(n) &amp;= c_1n + c_2(n - 1) + c_4(n - 1) + c_5\bigg[\frac{n(n+1)}{2} - 1\bigg] + (c_6 + 
                 c_7)\bigg[\frac{n(n-1)}{2}\bigg] + c_8(n - 1) \\
              &amp;= \bigg[\frac{c_5}{2} + \frac{c_6}{2} + \frac{c_7}{2}\bigg]n^2 + (c_1 + \dots + c_8)n - (c_2 + \dots + c_8)
    \end{split}}\)</span>\)</span> or equivalently, if we let <span class="arithmatex">\(c_n\)</span>
simplify to some constants <span class="arithmatex">\(a\)</span>, <span class="arithmatex">\(b\)</span> and
<span class="arithmatex">\(c\)</span> then <span class="arithmatex">\(<span class="arithmatex">\(T(n) = an^2 + bn - c\)</span>\)</span></p>
<h2 id="merge-sort">Merge Sort<a class="headerlink" href="#merge-sort" title="Permanent link">&para;</a></h2>
<p>Merge sort closely follows the divide-and-conquer paradigm. Intuitively, it operates as follows.</p>
<dl>
<dt>Divide:</dt>
<dd>
<p>Divide the <span class="arithmatex">\(n\)</span>-element sequence to be sorted into two
subsequences of <span class="arithmatex">\(n = 2\)</span> elements each.</p>
</dd>
<dt>Conquer:</dt>
<dd>
<p>Sort the two subsequences recursively using merge sort.</p>
</dd>
<dt>Combine:</dt>
<dd>
<p>Merge the two sorted subsequences to produce the sorted answer.</p>
</dd>
</dl>
<p>::: algorithm
[Merge-Sort]{.smallcaps} <span class="arithmatex">\((A,p,r) \to A[p \dots r]\)</span></p>
<p>::: algorithmic
<span class="arithmatex">\(q = \lfloor (p + r)/2 \rfloor\)</span></p>
<p>[Merge-Sort(<span class="arithmatex">\(A,p,q\)</span>)]{.smallcaps}</p>
<p>[Merge-Sort(<span class="arithmatex">\(A,q + 1,r\)</span>)]{.smallcaps}</p>
<p>[Merge(<span class="arithmatex">\(A,p,q,r\)</span>)]{.smallcaps}
:::
:::</p>
<ol>
<li>
<p>Split the deck into two piles, until these become simple enoughan
    array of size <span class="arithmatex">\(1\)</span>.</p>
</li>
<li>
<p>Sort the left pile and sort the right pile using
    [<code>Merge-Sort()</code>]{style="background-color: light-gray"}.</p>
</li>
<li>
<p>Merge both piles into the final pile.</p>
</li>
</ol>
<p>::: list</p>
<p>In the [<code>Merge-Sort(A,p,r)</code>]{style="background-color: light-gray"}, the
floor function is used to determine
[<code>q</code>]{style="background-color: light-gray"}, so in the case there's a
decimalit will result in an integer, ex.
<span class="arithmatex">\(\lfloor 7.5\rfloor = 7\)</span>.
:::</p>
<p>It may also be helpful to use a diagram like before to fully understand
what's happening. The number in red denotes the order in which steps are
processed.</p>
<p>::: center
<img alt="image" src="../Figure/2/merge_sort.png" width="\textwidth" />
:::</p>
<p>If you prefer are more concrete example, look at the code I wrote on the
left-side, which demonstrate how recursion works in this sorting
algorithm. Each indent indicates the recursion depth.</p>
<dl>
<dt>Step 1 to 3:</dt>
<dd>
<p>Calls [<code>Merge-Sort(A,p,q)</code>]{style="background-color: light-gray"} to
split the left children with different values of <span class="arithmatex">\(q\)</span>
and <span class="arithmatex">\(r\)</span> (passing parameter by value).</p>
</dd>
<dt>Step 4:</dt>
<dd>
<p>Since left child can no longer split, call
[<code>Merge-Sort(A,q+1,r)</code>]{style="background-color: light-gray"} to
work on right child.</p>
</dd>
<dt>Step 5:</dt>
<dd>
<p>If both left and right child are already split, merge them by
[<code>Merge(A,p,q,r)</code>]{style="background-color: light-gray"}.</p>
</dd>
<dt>Step 6:</dt>
<dd>
<p>Trace back to tree structure and find the node that does not
complete the splitting, call
[<code>Merge-Sort(A,q+1,r)</code>]{style="background-color: light-gray"} to
work on the right children.</p>
</dd>
<dt>Step 7 to 8:</dt>
<dd>
<p>The same process is done as for Step 3 and 4.</p>
</dd>
<dt>Step 9:</dt>
<dd>
<p>Like in Step 5, merge them by
[<code>Merge(A,p,q,r)</code>]{style="background-color: light-gray"}.</p>
</dd>
</dl>
<p>Most of the steps are just repeated for the other half of the array,
until all children have complete the splitting, then they are merged
together.</p>
<h3 id="merge-algorithm">Merge Algorithm<a class="headerlink" href="#merge-algorithm" title="Permanent link">&para;</a></h3>
<p>The key operation of the merge sort algorithm is the merging of two sorted sequences, after divide and conquer.</p>
<p>::: algorithm
[Merge]{.smallcaps} <span class="arithmatex">\((A,p,q,r) \to A[p \dots q]\)</span> and <span class="arithmatex">\(A[q + 1 \dots r]\)</span>
where <span class="arithmatex">\(p \leq q \leq r\)</span></p>
<p>::: algorithmic
<span class="arithmatex">\(n_1 = q - p + 1\)</span></p>
<p><span class="arithmatex">\(n_2 = r - q\)</span></p>
<p>Let L[1 ...<span class="arithmatex">\(n_1 + 1\)</span>] and L[1 ...<span class="arithmatex">\(n_2 + 1\)</span>] be new arrays</p>
<p><span class="arithmatex">\(L[i] = A[p + i - 1]\)</span></p>
<p><span class="arithmatex">\(R[j] = A[q + j]\)</span> <span class="arithmatex">\(L[n_1 + 1] = \infty\)</span></p>
<p><span class="arithmatex">\(R[n_2 + 1] = \infty\)</span> <span class="arithmatex">\(i = 1\)</span> <span class="arithmatex">\(j = 1\)</span></p>
<p><span class="arithmatex">\(A[k] = L[i]\)</span> <span class="arithmatex">\(i = i + 1\)</span> <span class="arithmatex">\(j = j + 1\)</span>
:::
:::</p>
<p>It may look like a lot, but it's pretty simple. Most of the code are
explained in the comments listed in the right. The main focus here is
the [<code>for</code>]{style="background-color: light-gray"} loop in Line 12 to 17.</p>
<p>::: center
<img alt="image" src="../Figure/2/merge.png" width="\textwidth" />
:::</p>
<p>The heavily shaded elements in
[<code>A</code>]{style="background-color: light-gray"} contain values that will be
copied over, and heavily shaded elements in
[<code>L[]</code>]{style="background-color: light-gray"} and
[<code>R[]</code>]{style="background-color: light-gray"} contain values that have
already been copied back into
[<code>A[]</code>]{style="background-color: light-gray"}. The lightly shaded
elements in [<code>A[]</code>]{style="background-color: light-gray"} indicate their
final value.</p>
<h3 id="time-complexity">Time Complexity<a class="headerlink" href="#time-complexity" title="Permanent link">&para;</a></h3>
<p>Let's discuss the time complexity of the following algorithm, which we
can break down to the divide-and-conquer paradigm.</p>
<ul>
<li>
<p>The time to split deck takes can be denoted by <span class="arithmatex">\(c_1\)</span>,
    as it takes constant timedoes not depend on any input.</p>
</li>
<li>
<p>The time to sort left pile and sort right pile can be denoted by
    <span class="arithmatex">\(2T(n/2)\)</span>, due to recursion, where the size is now
    divided by two, <span class="arithmatex">\(n/2\)</span>.</p>
</li>
<li>
<p>The time to merge piles can be denoted by <span class="arithmatex">\(c_2n + c_3\)</span>,
    as it takes linear timeonly the
    [<code>for</code>]{style="background-color: light-gray"} loop depends on input
    size, while the rest take constant time, thus simplified to that.</p>
</li>
</ul>
<p>The time complexity results to
<span class="arithmatex">\(<span class="arithmatex">\(T(n) = c_1 + T(n/2) + T(n/2) + c_2n + c_3\)</span>\)</span> Our goal is
to determine the most rapidly growing term in <span class="arithmatex">\(T(n)\)</span> and so
we can set a few rules. We set constants <span class="arithmatex">\(c_n\)</span> to either:</p>
<ul>
<li>
<p><span class="arithmatex">\(0\)</span>, if they will not be significant in the most
    rapidly growing term or ...</p>
</li>
<li>
<p><span class="arithmatex">\(1\)</span>, if they will be</p>
</li>
</ul>
<p>For <span class="arithmatex">\(T(n)\)</span>, when <span class="arithmatex">\(n &gt; 1\)</span>, we can set
<span class="arithmatex">\(c_1\)</span> and <span class="arithmatex">\(c_3\)</span> to <span class="arithmatex">\(0\)</span> and
<span class="arithmatex">\(c_2\)</span> to <span class="arithmatex">\(1\)</span>, which simplifies to:
<span class="arithmatex">\(<span class="arithmatex">\(T(n) = \begin{cases}c_1 &amp; \text{if}\ n = 1 \\ 2T(n/2) + n &amp; \text{if}\ n &gt; 1 \end{cases}\)</span>\)</span></p>
<p>::: list</p>
<p>Note that when <span class="arithmatex">\(n = 1\)</span>, the code inside
[<code>if ... else</code>]{style="background-color: light-gray"} wont run, as
there's only one element <span class="arithmatex">\(p \nless r\)</span> or
<span class="arithmatex">\(1 \nless 1\)</span>, so we write it as a constant.
:::</p>
<p>In order to solve the recurrence, when <span class="arithmatex">\(n &gt; 1\)</span>, we need a
base case, so for simplicity, <span class="arithmatex">\(T(1) = 0\)</span> and we can make a
deduction from it.</p>
<p>::: tabu
c | c c | c <span class="arithmatex">\(n\)</span> &amp; <span class="arithmatex">\(T(n/2)\)</span> &amp;
<span class="arithmatex">\(2T(n/2) + n\)</span> &amp; <span class="arithmatex">\(n\log_2{n}\)</span>\
<span class="arithmatex">\(2\)</span> &amp; <span class="arithmatex">\(0\)</span> &amp; <span class="arithmatex">\(2(0) + 2 = 2\)</span> &amp;
<span class="arithmatex">\(2\)</span>\
<span class="arithmatex">\(4\)</span> &amp; <span class="arithmatex">\(2\)</span> &amp; <span class="arithmatex">\(2(2) + 4 = 8\)</span> &amp;
<span class="arithmatex">\(8\)</span>\
<span class="arithmatex">\(8\)</span> &amp; <span class="arithmatex">\(8\)</span> &amp; <span class="arithmatex">\(2(8) + 8 = 24\)</span> &amp;
<span class="arithmatex">\(24\)</span>\
<span class="arithmatex">\(16\)</span> &amp; <span class="arithmatex">\(24\)</span> &amp; <span class="arithmatex">\(2(24) + 16 = 64\)</span> &amp;
<span class="arithmatex">\(64\)</span>\
<span class="arithmatex">\(32\)</span> &amp; <span class="arithmatex">\(64\)</span> &amp; <span class="arithmatex">\(2(64) + 32 = 160\)</span>
&amp; <span class="arithmatex">\(160\)</span>\
:::</p>
<p>Examining the numbers allows us to form an educated guess it is growing
by a function of <span class="arithmatex">\(n\log_2{n}\)</span>, which can also be deducted
by drawing a recursion tree.</p>
<ol>
<li>We start by representing <span class="arithmatex">\(T(n) = 2T(n/2) + n\)</span> as a
    graph where we put the non-recursive part (<span class="arithmatex">\(n\)</span> in this
    case) on the top row and put each recursive part on a row below.</li>
</ol>
<p>::: center
<img alt="image" src="../Figure/2/ex_recursion1.png" width="40%" />
:::</p>
<ol>
<li>Then expand downwards for the next level.</li>
</ol>
<p>::: center
<img alt="image" src="../Figure/2/ex_recursion2.png" width="47.5%" />
:::</p>
<ol>
<li>Repeat the same process. Eventually, it will reach a certain height
    which it reaches the base case and stop.</li>
</ol>
<p>::: center
<img alt="image" src="../Figure/2/ex_recursion3a.png" width="70%" />
:::</p>
<p>::: {#height_avl}
If you notice the sum of the non-recursive elements for each level is
<span class="arithmatex">\(n\)</span>. Let's denote the depth or height of the tree as
<span class="arithmatex">\(h\)</span> and so we can say the time complexity is
:::</p>
<p><span class="arithmatex">\(<span class="arithmatex">\(T(n) = n \times h\)</span>\)</span> It will eventually reach the base
case which we set to some constant when <span class="arithmatex">\(n=1\)</span>, where
<span class="arithmatex">\(T(1) = 1\)</span>. We can rewrite the fraction in terms of the
depth, <span class="arithmatex">\(h\)</span>, where
<span class="arithmatex">\(<span class="arithmatex">\(\frac{n}{2^h} = 1 \to n = 2^h \to h = \log_2{n}\)</span>\)</span> Thus,
the time complexity is <span class="arithmatex">\(<span class="arithmatex">\(T(n) = n\log_2{n}\)</span>\)</span> If you recall
the order-of-growth from Lecture 2, we know that
<span class="arithmatex">\(n\log{n} &lt; n^2\)</span>, and so merge sorting beats insertion sort
in the worst-case scenario, as it grows much more slowly.</p>
<h2 id="selection-sort">Selection Sort<a class="headerlink" href="#selection-sort" title="Permanent link">&para;</a></h2>
<p>The final sorting algorithm will cover is selection sort.</p>
<p>::: algorithm
[Selection-Sort<span class="arithmatex">\((A,n) \to A[1 \dots\ n]\)</span>]{.smallcaps}</p>
<p>::: algorithmic
<span class="arithmatex">\(min = i\)</span> <span class="arithmatex">\(min = j\)</span> Interchange <span class="arithmatex">\(A[i]\)</span> with <span class="arithmatex">\(A[min]\)</span>
:::
:::</p>
<ol>
<li>
<p>Select the first element as
    [<code>min</code>]{style="background-color: light-gray"}</p>
</li>
<li>
<p>Compare [<code>min</code>]{style="background-color: light-gray"} with the
    second element. If the second element is smaller than minimum,
    assign the second element as
    [<code>min</code>]{style="background-color: light-gray"}. Repeat until last
    element.</p>
</li>
<li>
<p>After each iteration, [<code>min</code>]{style="background-color: light-gray"}
    is placed in the front of the unsorted list.</p>
</li>
<li>
<p>For each iteration, indexing starts from the first unsorted element.
    The steps are repeated until sorted.</p>
</li>
</ol>
<p>Let's use the example as we did for insertion sort, which is the
following array with 6 elements.</p>
<p>::: center
<img alt="image" src="../Figure/2/insertion_arr.png" width="45%" />
:::</p>
<p>The first iteration would like something like this. Let's denote the
[<code>min</code>]{style="background-color: light-gray"} in green and the line to
the element it's being compared to. The arrow indicates a swap to be
made.</p>
<p>::: center
<img alt="image" src="../Figure/2/selection_sort1.png" width="48%" />
:::</p>
<p>In the next iteration, the first unsorted element is
[<code>A[2]</code>]{style="background-color: light-gray"}, so it starts at
<span class="arithmatex">\(3\)</span>.</p>
<p>::: center
<img alt="image" src="../Figure/2/selection_sort2.png" width="48%" />
:::</p>
<p>Then it is repeated until all the elements are placed at their correct
positions.</p>
<h3 id="time-complexity_1">Time Complexity<a class="headerlink" href="#time-complexity_1" title="Permanent link">&para;</a></h3>
<p>As we have covered for the other algorithm, let's analyze the time complexity of selection sort.</p>
<p>::: algorithm
::: algorithmic
<span class="arithmatex">\(min = i\)</span></p>
<p><span class="arithmatex">\(min = j\)</span></p>
<p>Interchange <span class="arithmatex">\(A[i]\)</span> with <span class="arithmatex">\(A[min]\)</span>
:::
:::</p>
<p>Combining each one of them, we get the following running time of
selection sort:
<span class="arithmatex">\(<span class="arithmatex">\(T(n) = c_1n + c_2(n-1) + c_3\sum_{j=2}^n j + c_4\sum_{j = 2}^n (j - 1) + c_5(n-1)\)</span>\)</span>
As we have previously done with insertion sort, we can simplify the
summation using the arithmetic series <span class="arithmatex">\(<span class="arithmatex">\({
    \begin{split}
         T(n) &amp;= c_1n + c_2(n-1) + c_3\bigg[\frac{n(n+1)}{2} - 1\bigg] + c_4\bigg[\frac{n(n-1)}{2}\bigg] + c_5(n-1) \\
             &amp;= \bigg[\frac{c_3}{2}+\frac{c_4}{2}\bigg]n^2 + (c_1 + \dots + c_5)n - (c_2 + \dots + c_5)
    \end{split}}\)</span>\)</span> or equivalently, if we let <span class="arithmatex">\(c_n\)</span>
simplify to some constants <span class="arithmatex">\(a\)</span>, <span class="arithmatex">\(b\)</span> and
<span class="arithmatex">\(c\)</span> then <span class="arithmatex">\(<span class="arithmatex">\(T(n) = an^2 + bn - c\)</span>\)</span> Comparing it
to the other two algorithms discussed, selection sort is on par with
insertion sort in the worst-case scenario and so merge sorting is better than selection sort as well.</p>
<h1 id="complexity-analysis">Complexity Analysis<a class="headerlink" href="#complexity-analysis" title="Permanent link">&para;</a></h1>
<h2 id="asymptotic-notations">Asymptotic Notations<a class="headerlink" href="#asymptotic-notations" title="Permanent link">&para;</a></h2>
<p>As covered briefly in the
growth rate of running time, it's hard to determine which algorithm is
better with no prior knowledge of the input size, so we consider the
asymptotic behavior of the two functions for very large input size
<span class="arithmatex">\(n\)</span>.</p>
<p>We use specific notations called asymptotic notations to express
mathematical properties of asymptotic efficiency.</p>
<p>::: dBox
::: definitionT
<strong>Definition 3.1</strong> (Asymptotic efficiency). <em>The study of how the
running time of an algorithm increases as the size of the input
increases without bound.</em>
:::
:::</p>
<p>There are three asymptotic notations, which will go over in this
lecture:</p>
<ul>
<li>
<p>Big-Oh notation, <span class="arithmatex">\(\text{O}()\)</span>, for the upper bound or
    worst-case complexity</p>
</li>
<li>
<p>Big-Omega notation, <span class="arithmatex">\(\Omega()\)</span>, for the lower bound or
    best-case complexity</p>
</li>
<li>
<p>Theta notation, <span class="arithmatex">\(\Theta()\)</span>, for the average bound or
    average-case complexity</p>
</li>
</ul>
<p>We can apply these to the previous lecture, which we covered three
different sorting algorithms with varying time complexity:</p>
<hr />
<div class="highlight"><pre><span></span><code><span class="linenos" data-linenos="1 "></span> Algorithm              Time Complexity          
<span class="linenos" data-linenos="2 "></span>                             Best                               Worst
</code></pre></div>
<p>Insertion Sort      <span class="arithmatex">\(\Omega(n)\)</span>         <span class="arithmatex">\(\text{O}(n^2)\)</span>
     Merge Sort     <span class="arithmatex">\(\Omega(n\log{n})\)</span>   <span class="arithmatex">\(\text{O}(n\log{n})\)</span>
   Selection Sort     <span class="arithmatex">\(\Omega(n^2)\)</span>        <span class="arithmatex">\(\text{O}(n^2)\)</span></p>
<hr />
<p>-3ex -0.1ex -.4ex 0.5ex .2ex Big-Oh Notation (O-notation) The notation
represents the upper bound of the running time of an algorithm. Thus, it
gives the worst-case complexity of an algorithm. <span class="arithmatex">\(<span class="arithmatex">\({
    \begin{aligned}
        \text{O}(g(n)) = \{f(n) \mid &amp; \text{ there exists positive constant } c \text{ and } n_0 \text{ such that } 0 \leq f(n) \leq cg(n) \\
        &amp; \text{ for all } n \geq n_0
    \end{aligned}}\)</span>\)</span></p>
<p>::: center
<img alt="image" height="5cm" src="../Figure/3/big0.png" />
:::</p>
<p>Some tips for determining <span class="arithmatex">\(\text{O}()\)</span> complexity:</p>
<ol>
<li>
<p>Ignore the constants: <span class="arithmatex">\(<span class="arithmatex">\(5n \to n\)</span>\)</span></p>
</li>
<li>
<p>Certain terms dominate other, which we ignore lower order terms:
    <span class="arithmatex">\(<span class="arithmatex">\(\text{O}(1) &lt; \text{O}(\log{n}) &lt; \text{O}(n) &lt; \text{O}(n\log{n}) &lt; \text{O}(n^2) &lt; \cdots &lt; \text{O}(2^n) &lt; \cdots &lt; \text{O}(n!) &lt; \text{O}(n^n)\)</span>\)</span></p>
</li>
</ol>
<p>It might be easier to understand if we have examples to determine the
big-Oh notation.</p>
<p>::: exampleT
<strong>Example 3.1</strong>. <em>Determine the upper bound <span class="arithmatex">\(\text{O}()\)</span>
for <span class="arithmatex">\(f(n)\)</span>:</em></p>
<ul>
<li>
<p><em><span class="arithmatex">\(f_A(n) = an^2 + bn + c\)</span> is
    <span class="arithmatex">\(\text{O}(n^2)\)</span></em></p>
</li>
<li>
<p><em><span class="arithmatex">\(f_B(n) = 2n + 3\)</span> is <span class="arithmatex">\(\text{O}(n)\)</span></em></p>
</li>
<li>
<p><em><span class="arithmatex">\(f_C(n) = 5 + (15 \cdot 20)\)</span> is
    <span class="arithmatex">\(\text{O}(1)\)</span></em></p>
</li>
<li>
<p><em><span class="arithmatex">\(f_D(n) = n^2\log{n} + n\)</span> is
    <span class="arithmatex">\(\text{O}(n^2\log{n})\)</span></em>
:::</p>
</li>
</ul>
<p>::: list</p>
<p>When writing the big-Oh notation, try to write the closest function to
the running time. While the function <span class="arithmatex">\(\text{O}(n^2)\)</span> is
true for <span class="arithmatex">\(f_B(n)\)</span>, the function <span class="arithmatex">\(\text{O}(n)\)</span>
is the closest to <span class="arithmatex">\(f_B(n)\)</span>.
:::</p>
<p>The rules for determining the <span class="arithmatex">\(\text{O}()\)</span> complexity are
as listed:</p>
<ol>
<li>
<p>If <span class="arithmatex">\(g(n) = \text{O}(G(n))\)</span> and
    <span class="arithmatex">\(f(n) = \text{O}(F(n))\)</span>, then:
    <span class="arithmatex">\(<span class="arithmatex">\(f(n) + g(n) = \text{O}(F(n)) + \text{O}(G(n)) = \text{O}(\text{max}[F(n), G(n)])\)</span>\)</span>
    <span class="arithmatex">\(<span class="arithmatex">\(f(n) \cdot g(n) = \text{O}(F(n)) \cdot \text{O}(G(n)) = \text{O}(F(n) \cdot G(n))\)</span>\)</span></p>
</li>
<li>
<p>If <span class="arithmatex">\(g(n) = \text{O}(kG(n))\)</span>, where <span class="arithmatex">\(k\)</span> is
    a constant, then <span class="arithmatex">\(g(n) = \text{O}(G(n))\)</span>.</p>
</li>
<li>
<p>If <span class="arithmatex">\(f(n)\)</span> is a polynomial of degree
    <span class="arithmatex">\(d\ (P(n) = \sum_{i=0}^d a_in^i\)</span> where
    <span class="arithmatex">\(a_d \neq 0)\)</span>, then <span class="arithmatex">\(f(n)\)</span> is
    <span class="arithmatex">\(\text{O}(n^d)\)</span>.</p>
</li>
</ol>
<p>-3ex -0.1ex -.4ex 0.5ex .2ex Big-Omega Notation (<span class="arithmatex">\(\Omega\)</span>-notation) The
notation represents the lower bound of the running time of an algorithm.
Thus, it provides the best-case complexity of an algorithm.
<span class="arithmatex">\(<span class="arithmatex">\({
    \begin{aligned}
        \Omega(g(n)) = \{f(n) \mid &amp; \text{ there exists positive constant } c \text{ and } n_0 \text{ such that } 0 \leq cg(n) \leq f(n) \\
        &amp; \text{ for all } n \geq n_0
    \end{aligned}}\)</span>\)</span></p>
<p>::: center
<img alt="image" height="5cm" src="../Figure/3/omega.png" />
:::</p>
<p>The rules for determining <span class="arithmatex">\(\text{O}()\)</span> complexity is also
true for determining the <span class="arithmatex">\(\Omega()\)</span> complexity. Let's use
an example from before.</p>
<p>::: exampleT
<strong>Example 3.2</strong>. <em>Determine the lower bound <span class="arithmatex">\(\Omega()\)</span> for
<span class="arithmatex">\(f(n) = 2n + 3\)</span>:</em></p>
<ol>
<li>
<p><em>If we look at the order-of-growth for functions,
    <span class="arithmatex">\(T(n)\)</span> belongs to the linear function, <span class="arithmatex">\(n\)</span>
    and if we define our lower and upper bounds as such
    <span class="arithmatex">(<span class="arithmatex">\({\overunderbraces{&amp;\br{2}{\text{Lower bound}}}%
        {&amp;1 &lt; \log{n} &lt; \sqrt{n} &lt;&amp; n &amp;&lt; n\log{n} &lt; n^2 &lt; n^3 &lt; \cdots &lt; 2^n &lt; 3^n &lt; \cdots &lt; n! &lt; n^n&amp;}
        {&amp; &amp;\br{2}{\text{Upper bound}}}}\)</span>\)</span></em></p>
</li>
<li>
<p><em>So the lower bound can be defined by any of the following:
    <span class="arithmatex">(<span class="arithmatex">\(\Omega(1) &lt; \Omega(\log{n}) &lt; \Omega(n)\)</span>\)</span></em></p>
</li>
<li>
<p><em>Similar to the upper bound, we want the function closest to
    <span class="arithmatex">\(f(n)\)</span> and so <span class="arithmatex">\(f(n) = 2n + 3\)</span> is
    <span class="arithmatex">\(\Omega(n)\)</span>.</em>
:::</p>
</li>
</ol>
<p>-3ex -0.1ex -.4ex 0.5ex .2ex Theta Notation (<span class="arithmatex">\(\Theta\)</span>-notation) The next
notation encloses the function from above and below. Since it represents
the upper and the lower bound of the running time of an algorithm, it is
used for analyzing the average-case complexity of an algorithm.
<span class="arithmatex">\(<span class="arithmatex">\({
    \begin{aligned}
        \text{O}(g(n)) = \{f(n) \mid &amp; \text{ there exists positive constant } c_1,\ c_2, \text{ and } n_0 \text{ such that } \\ 
        &amp;\ 0 \leq c_1g(n) \leq f(n) \leq c_2g(n) \text{ for all } n \geq n_0
    \end{aligned}}\)</span>\)</span></p>
<p>::: center
<img alt="image" height="5cm" src="../Figure/3/theta.png" />
:::</p>
<p>Equivalently, <span class="arithmatex">\(f(n)\)</span> is <span class="arithmatex">\(\Theta(g(n))\)</span> if and
only if <span class="arithmatex">\(f(n)\)</span> is both <span class="arithmatex">\(\text{O}(g(n))\)</span> and
<span class="arithmatex">\(\Omega(g(n))\)</span>.</p>
<p>One notable example which we used previously is the function
<span class="arithmatex">\(f(n) = 2n + 3\)</span>, which as we demonstrated in previous
notations are <span class="arithmatex">\(\text{O}(n)\)</span> and <span class="arithmatex">\(\Omega(n)\)</span>,
thus <span class="arithmatex">\(f(n)\)</span> is <span class="arithmatex">\(\Theta(n)\)</span>.</p>
<h2 id="complexity-of-code-structures">Complexity of Code Structures<a class="headerlink" href="#complexity-of-code-structures" title="Permanent link">&para;</a></h2>
<p>Loops are considered as dynamic if they depend on input size, otherwise they are
static statements, everything within a loop is considered as static
statementtakes a constant amount of time, <span class="arithmatex">\(\text{O}(1)\)</span>.
The complexity is determined by:</p>
<ul>
<li>number of iterations in the loops <span class="arithmatex">\(\times\)</span> number of
    static statement</li>
</ul>
<p>-3ex -0.1ex -.4ex 0.5ex .2ex For Loop The following example is a simple
for loop:</p>
<div class="highlight"><pre><span></span><code><span class="linenos" data-linenos="1 "></span>for (int i = 0; i &lt; n; i++) { 
<span class="linenos" data-linenos="2 "></span>    // statement
<span class="linenos" data-linenos="3 "></span>}
</code></pre></div>
<p>The for loop is a dynamic statement, as it depends on the size of
<span class="arithmatex">\(n\)</span>. We are interested in the amount of times
[<code>statement</code>]{style="background-color: light-gray"} runs, which
determines the time complexity of the following loop. Suppose
<span class="arithmatex">\(n = 3\)</span> then let's determine how many iterations:</p>
<p>::: tabu
c c c Iteration &amp; <span class="arithmatex">\(i\)</span> &amp;\
&amp; i = 0 &amp;\
2 &amp; i = 1 &amp;\
3 &amp; i = 2 &amp;\
4 &amp; i = 3 &amp;\
:::</p>
<p>You can see that the loop executes <span class="arithmatex">\(3\)</span> times or in general,
we can say <span class="arithmatex">\(n\)</span> times. Thus, the time complexity is:
<span class="arithmatex">\(<span class="arithmatex">\(n \cdot 1 = \text{O}(n)\)</span>\)</span></p>
<p>Note that there might be few variations of the for loop. Suppose there
are also consecutive statements:</p>
<div class="highlight"><pre><span></span><code><span class="linenos" data-linenos="1 "></span>for (int i = 0; i &lt; n; i++) { 
<span class="linenos" data-linenos="2 "></span>    // statement
<span class="linenos" data-linenos="3 "></span>}
<span class="linenos" data-linenos="4 "></span>for (int i = 1; i &lt;= n; i++) {
<span class="linenos" data-linenos="5 "></span>    // statement
<span class="linenos" data-linenos="6 "></span>}
</code></pre></div>
<p>In both examples, the loop executes for <span class="arithmatex">\(n\)</span> times. When we
have consecutive statements, we would just add them together. If you
recall, we ignore any constants of lower order terms. Thus, the time
complexity is:
<span class="arithmatex">\(<span class="arithmatex">\(\underbrace{n \cdot 1}_{\substack{\text{The first} \\ \text{for loop}}} + \underbrace{n \cdot 1}_{\substack{\text{The second} \\ \text{for loop}}} = 2n = \text{O}(n)\)</span>\)</span></p>
<p>Note that this is not always the case for every for loop, as it depends
on the initialization, condition test, and update statement. Suppose we
have the following for loop to analyze:</p>
<div class="highlight"><pre><span></span><code><span class="linenos" data-linenos="1 "></span>for (int i = 1; i &lt;= n; i = i * 2) {
<span class="linenos" data-linenos="2 "></span>    // statement
<span class="linenos" data-linenos="3 "></span>}
</code></pre></div>
<p>Let's list out each iterations of the loop, till <span class="arithmatex">\(k\)</span>
iterations, since we do not know how many times this loop will execute.</p>
<p>::: tabu
c c c Iteration &amp; <span class="arithmatex">\(i\)</span>\
&amp; i = 1 &amp; <span class="arithmatex">\(2^0\)</span>\
2 &amp; i = 2 &amp; <span class="arithmatex">\(2^1\)</span>\
3 &amp; i = 4 &amp; <span class="arithmatex">\(2^2\)</span>\
&amp; \
<span class="arithmatex">\(k\)</span> &amp; i = <span class="arithmatex">\(2^{k - 1}\)</span> &amp;\
:::</p>
<p>From the condition, we know that the loop will terminate once
[<code>i &gt; n</code>]{style="background-color: light-gray"}. So we assume
<span class="arithmatex">\(i = n\)</span>, when it has reach <span class="arithmatex">\(k\)</span> iterations; our
very last iteration. Then we will solve for <span class="arithmatex">\(k\)</span>:
<span class="arithmatex">\(<span class="arithmatex">\({
\begin{split}
2^{k - 1} &amp;= n \\
k - 1 &amp;= \log_2{n} \\
k &amp;= \log_2{n} + 1 
\end{split}}\)</span>\)</span></p>
<p>If you recall from earlier, we ignore lower order terms. Thus, the time
complexity is:
<span class="arithmatex">\(<span class="arithmatex">\((\log_2{n} + 1) \cdot 1 = \text{O}(\log_2{n})\)</span>\)</span></p>
<p>-3ex -0.1ex -.4ex 0.5ex .2ex Nested Loop The following example is a
nested for loop:</p>
<div class="highlight"><pre><span></span><code><span class="linenos" data-linenos="1 "></span>for (int i = 0; i &lt; n; i++) {   
<span class="linenos" data-linenos="2 "></span>    for (int j = 0; j &lt; n, j++) { 
<span class="linenos" data-linenos="3 "></span>        // statement                      
<span class="linenos" data-linenos="4 "></span>    }
<span class="linenos" data-linenos="5 "></span>}
</code></pre></div>
<p>As we covered earlier, the following for loop executes <span class="arithmatex">\(n\)</span>
times. Suppose now we have an inner loop, which also executes
<span class="arithmatex">\(n\)</span> times, then the statement is run
<span class="arithmatex">\(n \times n\)</span> times. Thus, the time complexity is:
<span class="arithmatex">\(<span class="arithmatex">\((n \cdot n) \cdot 1 = \text{O}(n^2)\)</span>\)</span></p>
<p>The general formula for a nested loop is the time complexity of the
outer loop times the inner loops. This also applies if we have a outer
while loop with an inner for loop.</p>
<p>-3ex -0.1ex -.4ex 0.5ex .2ex If Else Statement The following example is
an if else statement:</p>
<div class="highlight"><pre><span></span><code><span class="linenos" data-linenos="1 "></span>if (n == 0) {
<span class="linenos" data-linenos="2 "></span>    // statement 1
<span class="linenos" data-linenos="3 "></span>} else {
<span class="linenos" data-linenos="4 "></span>    for (int i = 0; i &lt; n; i++) { 
<span class="linenos" data-linenos="5 "></span>        // statement 2
<span class="linenos" data-linenos="6 "></span>    }
<span class="linenos" data-linenos="7 "></span>}
</code></pre></div>
<p>If you notice, there's two possibilities that could occur: the if part,
where[<code>statement 1</code>]{style="background-color: light-gray"} will run
once, <span class="arithmatex">\(\text{O}(1)\)</span> or the else part, where
[<code>statement 2</code>]{style="background-color: light-gray"} will run for
<span class="arithmatex">\(n\)</span> times, <span class="arithmatex">\(\text{O}(n)\)</span>.</p>
<p>In general, the time complexity of an if else statement is:
<span class="arithmatex">\(<span class="arithmatex">\(\text{O}(if-else) = \text{O}\Big(\text{max}\Big[\text{O}(\text{condition1}), \text{O}(\text{condition2}), \dots, \text{O}(\text{branch}1), \text{O}(\text{branch2}), \dots\Big]\Big)\)</span>\)</span>
As we are typically interested in the worst-cases, we only consider the
branch with the largest running time. The condition runs once and then
we add whichever is larger, which is the else part, thus, the time
complexity is: <span class="arithmatex">\(<span class="arithmatex">\(1 + n = \text{O}(n)\)</span>\)</span> or equivalently
<span class="arithmatex">\(<span class="arithmatex">\(\text{O}\Big(\text{max}\Big[\text{O}(1), \text{O}(1), \text{O}(n)\Big]\Big) = \text{O}(n)\)</span>\)</span></p>
<p>-3ex -0.1ex -.4ex 0.5ex .2ex Switch Statement The following example is a
switch statement:</p>
<div class="highlight"><pre><span></span><code><span class="linenos" data-linenos=" 1 "></span>switch (key) {
<span class="linenos" data-linenos=" 2 "></span>    case &#39;a&#39;:
<span class="linenos" data-linenos=" 3 "></span>        for (int i = 0; i &lt; n; i++) { 
<span class="linenos" data-linenos=" 4 "></span>            // statement 1
<span class="linenos" data-linenos=" 5 "></span>        }
<span class="linenos" data-linenos=" 6 "></span>    case &#39;b&#39;:
<span class="linenos" data-linenos=" 7 "></span>        for (int i = 0; i &lt; n; i++) {   
<span class="linenos" data-linenos=" 8 "></span>            for (int j = 0; j &lt; n, j++) { 
<span class="linenos" data-linenos=" 9 "></span>                // statement 2                      
<span class="linenos" data-linenos="10 "></span>            }
<span class="linenos" data-linenos="11 "></span>        }
<span class="linenos" data-linenos="12 "></span>    default:
<span class="linenos" data-linenos="13 "></span>        // statement 3
<span class="linenos" data-linenos="14 "></span>        break;
<span class="linenos" data-linenos="15 "></span>}
</code></pre></div>
<p>Similar to the if else statement, we only consider the case with the
largest running time, including the default case. In this example, for
[<code>case b</code>]{style="background-color: light-gray"},
[<code>statement 2</code>]{style="background-color: light-gray"} will run for <span class="arithmatex">\(n^2\)</span>
times, <span class="arithmatex">\(\text{O}(n^2)\)</span>. Thus, the time complexity is:
<span class="arithmatex">\(<span class="arithmatex">\(1 + n^2 = \text{O}(n^2)\)</span>\)</span> or equivalently
<span class="arithmatex">\(<span class="arithmatex">\(\text{O}\Big(\text{max}\Big[\text{O}(1), \text{O}(n), \text{O}(n^2), \text{O}(1)\Big]\Big) = \text{O}(n^2)\)</span>\)</span></p>
<h1 id="recurrence-equations">Recurrence Equations<a class="headerlink" href="#recurrence-equations" title="Permanent link">&para;</a></h1>
<p>-4ex -1ex -.4ex 1ex .2ex Introduction In Lecture 2, we described the
worst-case running time <span class="arithmatex">\(T(n)\)</span> of merge-sort procedure by
the recurrence:
<span class="arithmatex">\(<span class="arithmatex">\(T(n) = \begin{cases} 1 &amp; \text{if}\ n = 1 \\ 2T(n/2) + n &amp; \text{if}\ n &gt; 1 \end{cases}\)</span>\)</span>
whose solution we claimed to be <span class="arithmatex">\(T(n) = \Theta(n\log n)\)</span>.
Previously, we didn't really have a general method for finding the form
of recurrences. Our goal for this lecture is to go in-depth in ways we
can analyze recursive algorithms and form a general formula.</p>
<p>::: dBox
::: definitionT
<strong>Definition 4.1</strong> (Recursive algorithm). <em>An algorithm which calls
itself to solve smaller problems.</em>
:::
:::</p>
<p>Recurrence can be polymorphic, meaning it can take many forms:</p>
<ul>
<li>
<p>A recursive algorithm which divides to two problem with equal sizes.
    <span class="arithmatex">\(<span class="arithmatex">\(T(n) = 2T(n/2) + \Theta(n)\)</span>\)</span></p>
</li>
<li>
<p>A recursive algorithm might divide subproblems into unequal sizes.
    <span class="arithmatex">\(<span class="arithmatex">\(T(n) = T(2n/3) + T(n/3) + \Theta(n)\)</span>\)</span></p>
</li>
<li>
<p>They are not necessarily constrained to being a constant fraction of
    the original problem size.
    <span class="arithmatex">\(<span class="arithmatex">\(T(n) = T(n-1) + \Theta(1)\)</span>\)</span></p>
</li>
</ul>
<p>-4ex -1ex -.4ex 1ex .2ex Finding the Asymptotic Bounds There are three
methods for solving recurrencesthat is, for obtaining asymptotic
"<span class="arithmatex">\(\Theta\)</span>" or "<span class="arithmatex">\(\text{O}\)</span>" bounds on the
solution:</p>
<ol>
<li>
<p>Substitution Method</p>
</li>
<li>
<p>Recursion-Tree Method</p>
</li>
<li>
<p>Master Method</p>
</li>
</ol>
<p>-3ex -0.1ex -.4ex 0.5ex .2ex Substitution Method This method is
powerful, but we must be able to guess the form of the answer in order
to apply it. It comprises of the following steps:</p>
<dl>
<dt>Step 1:</dt>
<dd>
<p>Try a few substitutions to find a pattern.</p>
</dd>
<dt>Step 2:</dt>
<dd>
<p>Guess the recurrence formula after <span class="arithmatex">\(k\)</span> iterations (in
terms of <span class="arithmatex">\(k\)</span> and <span class="arithmatex">\(n\)</span>).</p>
</dd>
<dt>Step 3:</dt>
<dd>
<p>Set <span class="arithmatex">\(k\)</span> so we get the base case.</p>
</dd>
<dt>Step 4:</dt>
<dd>
<p>Put <span class="arithmatex">\(k\)</span> back into the formula to find a potential
closed form.</p>
</dd>
<dt>Step 5:</dt>
<dd>
<p>Prove the potential closed form using induction.</p>
</dd>
</dl>
<p>Using the merge-sort algorithm as an example, which has the following
recurrence:
<span class="arithmatex">\(<span class="arithmatex">\(T(n) = \begin{cases} 1 &amp; \text{if}\ n = 1 \\ 2T(n/2) + n &amp; \text{if}\ n &gt; 1 \end{cases}\)</span>\)</span>
Let's go step-by-step, as described.</p>
<ol>
<li>
<p>The easiest way to find a pattern, is by simply writing out the
    first few iterations. Let's denote <span class="arithmatex">\(k\)</span> as our number of
    iterations starting from <span class="arithmatex">\(1\)</span>.
    <span class="arithmatex">\(<span class="arithmatex">\({\begin{split}
                k &amp;= 1 &amp; T(n) &amp;= 2T(n/2) + n \\
                k &amp;= 2 &amp; T(n) &amp;= 2\Big[2T(n/4) + n/2\Big] + n = 4 \cdot T(n/4) + 2n \\
                k &amp;= 3 &amp; T(n) &amp;= 2\bigg[2\Big[2T(n/8) + n/4\Big] + n/2\bigg] + n = 8 \cdot T(n/8) + 3n \\
            \end{split}}\)</span>\)</span></p>
</li>
<li>
<p>Our goal is to generalize this for <span class="arithmatex">\(k\)</span> iterations. In
    other words, relating each of the constants to <span class="arithmatex">\(k\)</span>. We
    can rewrite it as such <span class="arithmatex">\(<span class="arithmatex">\({\begin{split}
                k &amp;= 1 &amp; T(n) &amp;= 2^1 \cdot T(n/2^1) + 1n \\
                k &amp;= 2 &amp; T(n) &amp;= 2^2 \cdot T(n/2^2) + 2n \\
                k &amp;= 3 &amp; T(n) &amp;= 2^3 \cdot T(n/2^3) + 3n \\
            \end{split}}\)</span>\)</span> Thus, we can form a general formula, using in
    terms of <span class="arithmatex">\(k\)</span> and <span class="arithmatex">\(n\)</span>
    <span class="arithmatex">\(<span class="arithmatex">\(T(n) = 2^k \cdot T(n/2^k) + kn\)</span>\)</span></p>
</li>
<li>
<p>We know the base case is set to <span class="arithmatex">\(T(1) = 1\)</span>. From our
    general formula, we can determine how many iterations there are in
    terms of <span class="arithmatex">\(n\)</span> to reach the base case, by solving for
    <span class="arithmatex">\(k\)</span>. <span class="arithmatex">\(<span class="arithmatex">\({\begin{split}
                \frac{n}{2^k} = 1 \ \to\ n &amp;= 2^k \\
                k &amp;= \log_2{n}
            \end{split}}\)</span>\)</span></p>
</li>
<li>
<p>Substituting <span class="arithmatex">\(k = \log_2{n}\)</span> back into the general
    formula, we get a potential closed form, as <span class="arithmatex">\(T()\)</span> is no
    longer inside our formula. <span class="arithmatex">\(<span class="arithmatex">\({\begin{split}
                T(n) &amp;= 2^{\log_2{n}} \cdot T(n/2^{\log_2{n}}) + n\log_2{n} \\
                &amp;= n + n\log_2{n}
            \end{split}}\)</span>\)</span></p>
</li>
<li>
<p>We can guess that the solution is
    <span class="arithmatex">\(T(n) = \text{O}(n\log{n})\)</span>. However, we need a
    definite proof that this is true, by using mathematical induction
    for the following statement.
    <span class="arithmatex">\(<span class="arithmatex">\(0 \leq T(n) \leq cn\log{n} \hspace{1cm} \exists c &gt; 0,\ \forall n \geq n_0\)</span>\)</span></p>
</li>
</ol>
<p>-2ex -0.1ex -.2ex .2ex .2ex Mathematical Induction In order to prove
something is true, we use mathematical induction. We must show that we
can choose the constant <span class="arithmatex">\(c\)</span> large enough so that
<span class="arithmatex">\(T(n) \leq cn\log{n}\)</span> is true.</p>
<ol>
<li>
<p>Remember, the base case is <span class="arithmatex">\(T(1) = 1\)</span>. Then for
    <span class="arithmatex">\(n = 1\)</span>, it yields
    <span class="arithmatex">\(T(1) \nleq c(1)\log{1} = 0\)</span>. Consequently, the base
    case fails to hold, so what now?</p>
</li>
<li>
<p>For asymptotic notation we can specify a specific bound,
    <span class="arithmatex">\(\forall n \geq n_0\)</span>, where <span class="arithmatex">\(n_0\)</span> is
    something we can choose. Thus <span class="arithmatex">\(n_0 = 2\)</span>, removing it
    from consideration in the induction proof.</p>
</li>
<li>
<p>The induction proof consists of three parts: the base case,
    inductive hypothesis and inductive step.</p>
</li>
</ol>
<p>Let's assume <span class="arithmatex">\(n\)</span> is some power of <span class="arithmatex">\(2\)</span> or
<span class="arithmatex">\(n = 2^k\)</span>, for sake of convenience.</p>
<dl>
<dt>Base Case:</dt>
<dd>
<p>Let <span class="arithmatex">\(k = 1\)</span> or <span class="arithmatex">\(n = 2\)</span> then:
<span class="arithmatex">\(<span class="arithmatex">\(T(2) = 2T(1) + 2 = 2 + 2 = 4 \leq c(2)\log{2}\)</span>\)</span> We
can see that the inequality holds true for the base case, such that
there <span class="arithmatex">\(c \geq 2\)</span>.</p>
</dd>
<dt>Inductive hypothesis:</dt>
<dd>
<p>We will now assume that our proposition,
<span class="arithmatex">\(T(n) = \text{O}(n\log{n})\)</span>, holds true for
<span class="arithmatex">\(k -1\)</span>, which equivalently is <span class="arithmatex">\(n/2\)</span>,
therefore: <span class="arithmatex">\(<span class="arithmatex">\(T(n/2) \leq c(n/2)\log{(n/2)}\)</span>\)</span> To prove
the inductive step, one assumes the induction hypothesis for
<span class="arithmatex">\(k-1\)</span> and then uses this assumption to prove that the
statement holds for <span class="arithmatex">\(k\)</span>. If instead, we assume our
hypothesis to hold for <span class="arithmatex">\(k\)</span>, then we must prove it holds
for <span class="arithmatex">\(k+1\)</span>.</p>
</dd>
<dt>Inductive step:</dt>
<dd>
<p>From our hypothesis, prove the guess of correct for
<span class="arithmatex">\(k\)</span>. Using the following:
<span class="arithmatex">\(<span class="arithmatex">\(T(n) = 2T(n/2) + n\)</span>\)</span> Since we know
<span class="arithmatex">\(T(n/2) \leq c(n/2)\log{(n/2)}\)</span>, then we can rewrite it
as such: <span class="arithmatex">\(<span class="arithmatex">\({\begin{split}
        T(n) &amp;\leq 2\Big[c(n/2)\log{(n/2)}\Big] + n \\
        &amp;\leq cn\log{(n/2)} + n = cn\log{n} - cn\log{2} + n \\
        &amp;\leq cn\log{n} + (1 - c)n \\
        &amp;\leq cn\log{n}\qquad (\forall c \geq 1)
    \end{split}}\)</span>\)</span> From the inductive step, we proved that
proposition is true as we found that there exists some value of
<span class="arithmatex">\(c\)</span>.</p>
</dd>
</dl>
<p>-3ex -0.1ex -.4ex 0.5ex .2ex Recursion-Tree Method In a recursion tree,
we sum the costs within each level of the tree to obtain a set of
per-level costs, and then we sum all the per-level costs to determine
the total cost of all levels of the recursion.</p>
<dl>
<dt>Step 1:</dt>
<dd>
<p>Start by substituting the parent with non-recursive part of the
formula and adding child nodes for each recursive part.</p>
</dd>
<dt>Step 2:</dt>
<dd>
<p>Expand each node repeating the step above, until you reach the base
case.</p>
</dd>
</dl>
<p>We already covered how to do this using merge-sort algorithm, so let's
start off simple, by using the following recurrence:
<span class="arithmatex">\(<span class="arithmatex">\(T(n) = \begin{cases} 1 &amp; \text{if}\ n = 1 \\ T(n-1) + n &amp; \text{if}\ n &gt; 1 \end{cases}\)</span>\)</span>
As usual, let's go step-by-step.</p>
<ol>
<li>
<p>The non-recursive part, <span class="arithmatex">\(n\)</span>, will be the parent node
    and the recursive part, <span class="arithmatex">\(T(n-1)\)</span>, will be the child
    node. The costs within each level is displayed in the right-hand
    side.</p>
<p>::: center
<img alt="image" src="../Figure/4/ex_recursion1.png" width="37.5%" />
:::</p>
</li>
<li>
<p>Expand on <span class="arithmatex">\(T(n-1)\)</span>, similar to the previous step.</p>
<p>::: center
<img alt="image" src="../Figure/4/ex_recursion2.png" width="37.5%" />
:::</p>
<p>Eventually, it will reach the base case of <span class="arithmatex">\(T(1) = 1\)</span>.
The fully expanded tree has height <span class="arithmatex">\(n\)</span>.</p>
<p>::: center
<img alt="image" src="../Figure/4/ex_recursion3.png" width="42.5%" />
:::</p>
<p>Notice how the sum of all the per-level cost is equivalently the
arithmetic series, thus:
<span class="arithmatex">\(<span class="arithmatex">\(T(n) = 1 + \cdots + (n-2) + (n-1) + n = \frac{n(n+2)}{2} = \Theta(n^2)\)</span>\)</span></p>
</li>
</ol>
<p>Suppose you consider something a bit more complex, which divides the
subproblems into unequal sizes, for the following recurrence:
<span class="arithmatex">\(<span class="arithmatex">\(T(n) = T(n/4) + T(n/2) + n^2\)</span>\)</span></p>
<ol>
<li>
<p>The non-recursive part, <span class="arithmatex">\(n^2\)</span>, will be the parent node
    and the recursive part, <span class="arithmatex">\(T(n/4)\)</span> and
    <span class="arithmatex">\(T(n/2)\)</span>, will be the child nodes.</p>
<p>::: center
<img alt="image" src="../Figure/4/ex_recursion4.png" width="37.5%" />
:::</p>
</li>
<li>
<p>Expand on <span class="arithmatex">\(T(n/4)\)</span> and <span class="arithmatex">\(T(n/2)\)</span>, similar
    to the previous step.</p>
<p>::: center
<img alt="image" src="../Figure/4/ex_recursion5.png" width="52.5%" />
:::</p>
<p>Eventually, it will reach the base case of <span class="arithmatex">\(T(1)\)</span>.</p>
<p>::: center
<img alt="image" src="../Figure/4/ex_recursion6.png" width="65%" />
:::</p>
<p>Notice how the sum of all the per-level cost is equivalently the
geometric series, thus:
<span class="arithmatex">\(<span class="arithmatex">\(T(n) = n^2\bigg[1 + \Big[\frac{5}{16}\Big] + \Big[\frac{5}{16}\Big]^2 + \cdots\bigg] = \Theta(n^2)\)</span>\)</span></p>
</li>
</ol>
<p>-3ex -0.1ex -.4ex 0.5ex .2ex Master Method The master method provides a
"cookbook" method for solving recurrences of the form:
<span class="arithmatex">\(<span class="arithmatex">\(T(n) = aT(n/b) + f(n)\)</span>\)</span> where <span class="arithmatex">\(a \geq 1\)</span>,
<span class="arithmatex">\(b &gt; 1\)</span> and <span class="arithmatex">\(f(n)\)</span> be a function of
<span class="arithmatex">\(<span class="arithmatex">\(f(n) = n^k\log^p{n}\)</span>\)</span> Note that there are various
variations of the master theorem, but this is definition is what I found
the easiest to understand. It consists of memorizing these three cases:</p>
<dl>
<dt>Case One:</dt>
<dd>
<p>If <span class="arithmatex">\(\log_b{a} &gt; k\)</span>, then
<span class="arithmatex">\(T(n) = \Theta(n^{\log_b{a}})\)</span>.</p>
</dd>
<dt>Case Two:</dt>
<dd>
<p>If <span class="arithmatex">\(\log_b{a} = k\)</span> and ...</p>
<p>(a) <span class="arithmatex">\(p &gt; -1\)</span>, then
    <span class="arithmatex">\(T(n) = \Theta(n^k\log^{p+1}{n})\)</span>.</p>
<p>(b) <span class="arithmatex">\(p = -1\)</span>, then
    <span class="arithmatex">\(T(n) = \Theta(n^k\log({\log{n}}))\)</span>.</p>
<p>(c) <span class="arithmatex">\(p &lt; -1\)</span>, then <span class="arithmatex">\(T(n) = \Theta(n^k)\)</span>.</p>
</dd>
<dt>Case Three:</dt>
<dd>
<p>If <span class="arithmatex">\(\log_ba &lt; k\)</span> and ...</p>
<p>(a) <span class="arithmatex">\(p \geq 0\)</span>, then
    <span class="arithmatex">\(T(n) = \Theta(n^k\log^{p}{n})\)</span>.</p>
<p>(b) <span class="arithmatex">\(p &lt; 0\)</span>, then <span class="arithmatex">\(T(n) =\Theta(n^k)\)</span>.</p>
</dd>
</dl>
<p>It looks a bit complicated at first glance, but once we get to the
examples, it becomes quite easy.</p>
<p>::: exampleT
<strong>Example 4.1</strong>. <em>Suppose we have the following recurrence:
<span class="arithmatex">(<span class="arithmatex">\(T(n) = 2T(n/2) + 1\)</span>\)</span></em></p>
<ol>
<li>
<p><em>We know <span class="arithmatex">\(a = 2\)</span> and <span class="arithmatex">\(b = 2\)</span>, but how do
    we get <span class="arithmatex">\(k\)</span> and <span class="arithmatex">\(p\)</span>? We can rewrite it in
    the form of <span class="arithmatex">\(n^k\log^p{n}\)</span>:
    <span class="arithmatex">(<span class="arithmatex">\(f(n) = 1 = n^0\log^0{n}\)</span>\)</span> You can confirm that both
    equations are identical, thus <span class="arithmatex">\(k = 0\)</span> and
    <span class="arithmatex">\(p = 0\)</span>.</em></p>
</li>
<li>
<p><em>Since <span class="arithmatex">\(\log_2{2} &gt; k\)</span>, then
    <span class="arithmatex">\(T(n) = \Theta(n^{\log_b{a}})\)</span>. Substituting in the
    values for <span class="arithmatex">\(a\)</span> and <span class="arithmatex">\(b\)</span>, we get:
    <span class="arithmatex">(<span class="arithmatex">\(T(n) = \Theta(n^{\log_2{2}}) = \Theta(n)\)</span>\)</span></em>
:::</p>
</li>
</ol>
<p>You can refer to this
<a href="https://youtu.be/kGcO-nAm9Vc">[video]{.underline}</a> for more examples
covering the three cases.</p>
<h1 id="elementary-data-structures">Elementary Data Structures<a class="headerlink" href="#elementary-data-structures" title="Permanent link">&para;</a></h1>
<p>-4ex -1ex -.4ex 1ex .2ex Stacks Stacks are dynamic sets in which the
element removed from the set by the delete operation is prespecified.
What defines a stack is that it implements a last-in, first-out (LIFO)
principle, so only the top element is accessible.</p>
<p>::: center
<img alt="image" height="3cm" src="../Figure/4/stack1.png" />
:::</p>
<p>There are three main methods on a stack:</p>
<ul>
<li>
<p>[<code>push(S,x)</code>]{style="background-color: light-gray"} - Inserts an
    object <span class="arithmatex">\(\colorbox{light-gray}{\texttt{x}}\)</span> onto top of Stack
    [<code>S</code>]{style="background-color: light-gray"}.</p>
</li>
<li>
<p>[<code>pop(S)</code>]{style="background-color: light-gray"} - Removes the top
    object of stack [<code>S</code>]{style="background-color: light-gray"}; if the
    stack is empty, an error occurs.</p>
</li>
<li>
<p>[<code>top(S)</code>]{style="background-color: light-gray"} - Returns the top
    object of the stack [<code>S</code>]{style="background-color: light-gray"},
    without removing it; if the stack is empty, an error occurs.</p>
</li>
</ul>
<p>::: center
<img alt="image" height="3cm" src="../Figure/4/stack2.png" />
:::</p>
<p>The following support methods should also be defined:</p>
<ul>
<li>
<p>[<code>size()</code>]{style="background-color: light-gray"} - Returns the
    number of objects in stack
    [<code>S</code>]{style="background-color: light-gray"}.</p>
</li>
<li>
<p>[<code>isEmpty()</code>]{style="background-color: light-gray"} - Indicates if
    stack [<code>S</code>]{style="background-color: light-gray"} is empty.</p>
</li>
</ul>
<p>We can implement each of the stack operations with just a few lines of
code:</p>
<p>::: algorithm
[Stack-Empty]{.smallcaps} <span class="arithmatex">\((S)\)</span></p>
<p>::: algorithmic
<span class="arithmatex">\(\textsc{True}\)</span> <span class="arithmatex">\(\textsc{False}\)</span>
:::
:::</p>
<p>::: algorithm
[Push]{.smallcaps} <span class="arithmatex">\((S,x)\)</span></p>
<p>::: algorithmic
<span class="arithmatex">\(S\,.\,top  = S\,.\,top  + 1\)</span> <span class="arithmatex">\(S[S\,.\,top ] = x\)</span>
:::
:::</p>
<p>::: algorithm
[Pop]{.smallcaps} <span class="arithmatex">\((S)\)</span></p>
<p>::: algorithmic
\"underflow\" <span class="arithmatex">\(S\,.\,top  = S\,.\,top  - 1\)</span> <span class="arithmatex">\(S[S\,.\,top  + 1]\)</span>
:::
:::</p>
<p>-3ex -0.1ex -.4ex 0.5ex .2ex Performance and Limitations Let's now look
at an array implementation of a stack
[<code>S</code>]{style="background-color: light-gray"} with <span class="arithmatex">\(7\)</span>
elements. Let <span class="arithmatex">\(S\,.\,top\)</span> be a pointer to keep track of the
last element (or top).</p>
<ol>
<li>
<p>When <span class="arithmatex">\(S\,.\,top = 0\)</span>, there is no elements and is
    empty, so stack [<code>S</code>]{style="background-color: light-gray"} has
    <span class="arithmatex">\(0\)</span> elements.</p>
<p>::: center
<img alt="image" height="2cm" src="../Figure/4/ex_stack1.png" />
:::</p>
</li>
<li>
<p>When we call [<code>push(S,15)</code>]{style="background-color: light-gray"},
    <span class="arithmatex">\(S\,.\,top\)</span> moves up by <span class="arithmatex">\(1\)</span> and inserts
    element <span class="arithmatex">\(15\)</span> to the stack.</p>
<p>::: center
<img alt="image" height="2cm" src="../Figure/4/ex_stack2.png" />
:::</p>
</li>
<li>
<p>Suppose we call the following:
    [<code>push(S,6)</code>]{style="background-color: light-gray"},
    [<code>push(S,2)</code>]{style="background-color: light-gray"} and
    [<code>push(S,3)</code>]{style="background-color: light-gray"}. The array is
    shown below.</p>
<p>::: center
<img alt="image" height="2cm" src="../Figure/4/ex_stack3.png" />
:::</p>
</li>
<li>
<p>When we call [<code>pop(S)</code>]{style="background-color: light-gray"},
    <span class="arithmatex">\(S\,.\,top\)</span> moves down by <span class="arithmatex">\(1\)</span> and returns
    the element that was removed, which is element <span class="arithmatex">\(3\)</span>.</p>
<p>::: center
<img alt="image" height="2cm" src="../Figure/4/ex_stack4.png" />
:::</p>
</li>
<li>
<p>Although element <span class="arithmatex">\(3\)</span> still appears in the array, it is
    no longer in the stack. When we call
    [<code>push(S,9)</code>]{style="background-color: light-gray"},
    <span class="arithmatex">\(S\,.\,top\)</span> moves up by <span class="arithmatex">\(1\)</span> and overwrites
    element <span class="arithmatex">\(3\)</span> with <span class="arithmatex">\(9\)</span>.</p>
<p>::: center
<img alt="image" height="2cm" src="../Figure/4/ex_stack5.png" />
:::</p>
</li>
</ol>
<p>If you notice, when pushing an element or popping an element off the
stack, it takes a constant amount of time. Let <span class="arithmatex">\(n\)</span> be the
numbers of elements in the stack.</p>
<ul>
<li>
<p>Each operation runs in time <span class="arithmatex">\(\text{O}(1)\)</span>.</p>
</li>
<li>
<p>The space used is <span class="arithmatex">\(\text{O}(n)\)</span>.</p>
</li>
</ul>
<p>There are a few limitations we must consider:</p>
<ul>
<li>
<p>The maximum size of the stack must be defined priority and cannot be
    changed.</p>
</li>
<li>
<p>When pushing a new element into a full stack, it causes an
    implementation error.</p>
</li>
</ul>
<p>-4ex -1ex -.4ex 1ex .2ex Queue Queue are another type of dynamic sets,
which implements first-in, first-out (FIFO) principle, so queue items
are removed in exactly the same order as they were added to the queue.</p>
<p>::: center
<img alt="image" height="3.5cm" src="../Figure/4/queue1.png" />
:::</p>
<p>There are exist the following operations on a queue:</p>
<ul>
<li>
<p>[<code>enqueue(Q,x)</code>]{style="background-color: light-gray"} - Inserts an
    element <span class="arithmatex">\(\colorbox{light-gray}{\texttt{x}}\)</span> at the rear of the queue
    [<code>Q</code>]{style="background-color: light-gray"}.</p>
</li>
<li>
<p>[<code>dequeue(Q)</code>]{style="background-color: light-gray"} - Removes the
    element at the front of queue
    [<code>Q</code>]{style="background-color: light-gray"}.</p>
</li>
<li>
<p>[<code>front()</code>]{style="background-color: light-gray"} - Returns the
    front element of the queue without removing it.</p>
</li>
<li>
<p>[<code>new()</code>]{style="background-color: light-gray"} - Creates an empty
    queue.</p>
</li>
<li>
<p>[<code>size()</code>]{style="background-color: light-gray"} - Returns the
    number of objects in queue.</p>
</li>
<li>
<p>[<code>isEmpty()</code>]{style="background-color: light-gray"} - Indicates if
    queue is empty.</p>
</li>
</ul>
<p>::: center
<img alt="image" height="1.5cm" src="../Figure/4/queue2.png" />
:::</p>
<p>Assume <span class="arithmatex">\(n = Q\,.\,length\)</span>. The pseudocode for enqueue and
dequeue is shown below:</p>
<p>::: algorithm
[Enqueue]{.smallcaps} <span class="arithmatex">\((Q,x)\)</span></p>
<p>::: algorithmic
<span class="arithmatex">\(Q[Q\,.\,tail] = x\)</span> <span class="arithmatex">\(Q\,.\,tail = 1\)</span>
:::
:::</p>
<p>::: algorithm
[Dequeue]{.smallcaps} <span class="arithmatex">\((Q)\)</span></p>
<p>::: algorithmic
<span class="arithmatex">\(x = Q[Q\,.\,head]\)</span> <span class="arithmatex">\(Q\,.\,head = 1\)</span>
:::
:::</p>
<p>Note that we didn't account for the error when underflow and overflow
occurs.</p>
<p>-3ex -0.1ex -.4ex 0.5ex .2ex Performance and Limitations Let's now look
at an array implementation of a queue
[<code>Q</code>]{style="background-color: light-gray"} with <span class="arithmatex">\(7\)</span>
elements. Let <span class="arithmatex">\(Q\,.\,head\)</span> be a pointer for the front of
the queue and <span class="arithmatex">\(Q\,.\,tail\)</span> be the back of the queue.</p>
<ol>
<li>
<p>When <span class="arithmatex">\(Q\,.\,head = Q\,.\,tail\)</span>, there is
    no elements, so queue [<code>Q</code>]{style="background-color: light-gray"}
    has <span class="arithmatex">\(0\)</span> elements.</p>
<p>::: center
<img alt="image" height="2cm" src="../Figure/4/ex_queue1.png" />
:::</p>
</li>
<li>
<p>When we call
    [<code>enqueue(Q,15)</code>]{style="background-color: light-gray"}, element
    <span class="arithmatex">\(15\)</span> is added to the queue then
    <span class="arithmatex">\(Q\,.\,tail\)</span> moves up by <span class="arithmatex">\(1\)</span>.</p>
<p>::: center
<img alt="image" height="2cm" src="../Figure/4/ex_queue2.png" />
:::</p>
</li>
<li>
<p>Suppose we call the following:
    [<code>enqueue(Q,6)</code>]{style="background-color: light-gray"},
    [<code>enqueue(Q,2)</code>]{style="background-color: light-gray"} and
    [<code>enqueue(Q,9)</code>]{style="background-color: light-gray"}. The array is
    shown below.</p>
<p>::: center
<img alt="image" height="2cm" src="../Figure/4/ex_queue3.png" />
:::</p>
</li>
<li>
<p>When we call [<code>dequeue(Q)</code>]{style="background-color: light-gray"},
    element <span class="arithmatex">\(15\)</span> located at the front of queue indicated by
    <span class="arithmatex">\(Q\,.\,head\)</span>, is removed then <span class="arithmatex">\(Q\,.\,head\)</span>
    moves up by <span class="arithmatex">\(1\)</span> to element <span class="arithmatex">\(6\)</span>.</p>
<p>::: center
<img alt="image" height="2cm" src="../Figure/4/ex_queue4.png" />
:::</p>
</li>
<li>
<p>As the final scenario, suppose we filled the array from
    <span class="arithmatex">\(Q[2 .. 7]\)</span>, as shown below.</p>
<p>::: center
<img alt="image" height="2cm" src="../Figure/4/ex_queue5.png" />
:::</p>
<p>When we call <span class="arithmatex">\(\colorbox{light-gray}{\texttt{enqueue(Q,x)}}\)</span> or add
one more element, <span class="arithmatex">\(Q\,.\,tail\)</span> will have to move up by
one where <span class="arithmatex">\(Q\,.\,head = Q\,.\,tail\)</span>.</p>
<p>::: center
<img alt="image" height="2cm" src="../Figure/4/ex_queue6.png" />
:::</p>
<p>But, if you recall, this means the queue is empty, which is not the
case and so the queue overflows.</p>
</li>
</ol>
<p>Similar to a stack, when enqueueing or dequeueing an element, it takes a
constant amount of time. Let <span class="arithmatex">\(n\)</span> be the numbers of elements
in the queue.</p>
<ul>
<li>Each operation runs in time <span class="arithmatex">\(\text{O}(1)\)</span>.</li>
</ul>
<p>There are also a few limitations we must consider which carries over for
queue:</p>
<ul>
<li>
<p>The maximum size of the stack must be defined priority and cannot be
    changed.</p>
</li>
<li>
<p>If we attempt to dequeue an element from an empty queue, the queue
    underflows.</p>
</li>
<li>
<p>If we attempt to enqueue an element from a full queue, the queue
    overflows and so we can only store <span class="arithmatex">\(n - 1\)</span> elements.</p>
</li>
</ul>
<p>-4ex -1ex -.4ex 1ex .2ex Linked Lists A collection of nodes that
together form a linear ordering. Unlike an array, however, in which the
linear order is determined by the array indices, the order in a linked
list is determined by a pointer in each object. It consists of:</p>
<ul>
<li>
<p>A sequence of nodes</p>
</li>
<li>
<p>Each node contains a value and link reference to some other node</p>
</li>
<li>
<p>The last node contains a null link</p>
</li>
</ul>
<p>-3ex -0.1ex -.4ex 0.5ex .2ex Singly Linked Lists The most basic of all
linked data structures, which are used to implement stacks and queues.
Each node has data and a pointer to the next node.</p>
<p>::: center
<img alt="image" src="../Figure/4/lnklist1.png" width="75%" />
:::</p>
<dl>
<dt>Searching a singly linked list.</dt>
<dd></dd>
</dl>
<p>::: algorithm
[List-Search]{.smallcaps} <span class="arithmatex">\((L,k)\)</span></p>
<p>::: algorithmic
<span class="arithmatex">\(x = L\,.\,head\)</span> <span class="arithmatex">\(x = x\,.\,next\)</span> <span class="arithmatex">\(x\)</span>
:::
:::</p>
<blockquote>
<p>To search a list of <span class="arithmatex">\(n\)</span> elements, the
[List-Search]{.smallcaps} procedure takes <span class="arithmatex">\(\Theta(n)\)</span>
time in the worst-case, since it may have to search the entire
listsimilar to insertion sort.</p>
</blockquote>
<dl>
<dt>Inserting into a singly linked list.</dt>
<dd>
<p>The [List-Insert]{.smallcaps} procedure splices the inserted
element, [<code>x</code>]{style="background-color: light-gray"}, onto the front
of the linked list.</p>
</dd>
</dl>
<p>::: center
<img alt="image" src="../Figure/5/singly_ins.png" width="\textwidth" />
:::</p>
<blockquote>
<p>The running time for [List-Insert]{.smallcaps} on a list of
<span class="arithmatex">\(n\)</span> elements is <span class="arithmatex">\(\text{O}(1)\)</span>.</p>
</blockquote>
<dl>
<dt>Deleting from a singly linked list.</dt>
<dd>
<p>The [List-Delete]{.smallcaps} procedure removes an element,
[<code>x</code>]{style="background-color: light-gray"}, from a linked list by
getting a pointer to <span class="arithmatex">\(\colorbox{light-gray}{\texttt{x}}\)</span> and it
splices [<code>x</code>]{style="background-color: light-gray"} out of the list
by updating pointers.</p>
</dd>
</dl>
<p>::: center
<img alt="image" src="../Figure/5/singly_del.png" width="\textwidth" />
:::</p>
<blockquote>
<p>The running time for [List-Delete]{.smallcaps} runs in
<span class="arithmatex">\(\text{O}(1)\)</span> time, but if we wish to delete an element
with a given key, <span class="arithmatex">\(\text{O}(n)\)</span> time is required in the
worst case.</p>
</blockquote>
<p>Some applications of singly linked lists are:</p>
<ul>
<li>
<p>Implement stacks and queues, as shown below.</p>
</li>
<li>
<p>Dynamic memory allocation, which will cover in the very end.</p>
</li>
</ul>
<p>-3ex -0.1ex -.4ex 0.5ex .2ex Doubly Linked Lists We add a pointer to the
previous node. Thus, we can go in either direction: forward or backward.</p>
<p>::: center
<img alt="image" src="../Figure/4/lnklist2.png" width="90%" />
:::</p>
<dl>
<dt>Searching a doubly linked list.</dt>
<dd>
<p>A singly and linked list uses the same algorithm for searching.
Thus, both take <span class="arithmatex">\(\Theta(n)\)</span> times in the worst-case to
search through a list of <span class="arithmatex">\(n\)</span> elements.</p>
</dd>
</dl>
<div class="highlight"><pre><span></span><code><span class="linenos" data-linenos="1 "></span>&lt;!-- --&gt;
</code></pre></div>
<dl>
<dt>Inserting into a doubly linked list.</dt>
<dd>
<p>The [List-Insert]{.smallcaps} procedure is also similar to the
singly, but now we also have to account for the previous pointer.</p>
</dd>
</dl>
<p>::: center
<img alt="image" src="../Figure/5/doubly_ins.png" width="\textwidth" />
:::</p>
<p>::: algorithm
[List-Insert]{.smallcaps} <span class="arithmatex">\((L,x)\)</span></p>
<p>::: algorithmic
<span class="arithmatex">\(x\,.\,next = L\,.\,head\)</span> <span class="arithmatex">\(L\,.\,head\,.\,prev = x\)</span> <span class="arithmatex">\(L\,.\,head = x\)</span>
<span class="arithmatex">\(x\,.\,prev =\)</span> [nil]{.smallcaps}
:::
:::</p>
<blockquote>
<p>The running time for [List-Insert]{.smallcaps} on a list of
<span class="arithmatex">\(n\)</span> elements is <span class="arithmatex">\(\text{O}(1)\)</span>.</p>
</blockquote>
<dl>
<dt>Deleting from a doubly linked list.</dt>
<dd>
<p>Likewise, same thing can be said for the [List-Delete]{.smallcaps}
procedure, in which we now have to also assign the previous pointer</p>
</dd>
</dl>
<p>::: center
<img alt="image" src="../Figure/5/doubly_del.png" width="\textwidth" />
:::</p>
<p>::: algorithm
[List-Delete]{.smallcaps} <span class="arithmatex">\((L,x)\)</span></p>
<p>::: algorithmic
<span class="arithmatex">\(x\,.\,prev\,.\,next = x\,.\,next\)</span> <span class="arithmatex">\(L\,.\,head = x\,.\,next\)</span>
<span class="arithmatex">\(x\,.\,next\,.\,prev = x\,.\,prev\)</span>
:::
:::</p>
<blockquote>
<p>The running time for [List-Delete]{.smallcaps} runs in
<span class="arithmatex">\(\text{O}(1)\)</span> time, but if we wish to delete an element
with a given key, <span class="arithmatex">\(\text{O}(n)\)</span> time is required in the
worst case.</p>
</blockquote>
<p>Some applications of doubly linked lists are:</p>
<ul>
<li>
<p>Browsers to implement backward and forward navigation of visited web
    pagesthe back and forward button.</p>
</li>
<li>
<p>Various application to implement Undo and Redo functionality.</p>
</li>
</ul>
<p>-3ex -0.1ex -.4ex 0.5ex .2ex Circularly Linked Lists A circularly singly
linked list is a variation of a linked list in which the last element is
linked to the first element. This forms a circular loop.</p>
<p>::: center
<img alt="image" src="../Figure/4/lnklist3.png" width="70%" />
:::</p>
<p>A circularly doubly linked list, in which in addition to the one above,
the first element is linked to the last element.</p>
<p>::: center
<img alt="image" src="../Figure/4/lnklist4.png" width="65%" />
:::</p>
<p>In a circularly linked list, we used a sentinelrepresented by the dark
grey node [<code>L.nil</code>]{style="background-color: light-gray"}.</p>
<p>::: center
<img alt="image" height="2.5cm" src="../Figure/5/sentinel.png" />
:::</p>
<p>It represents [nil]{.smallcaps} which lies between the head and tail. It
functions like any other object in a doubly linked list, which it has a
pointer from the previous and next node. Below are the procedures used
for circularly doubly linked list with sentinel.</p>
<p>::: algorithm
[List-Search/]{.smallcaps} <span class="arithmatex">\((L,k)\)</span></p>
<p>::: algorithmic
<span class="arithmatex">\(x = L\,.\,nil\,.\,next\)</span> <span class="arithmatex">\(x = x\,.\,next\)</span> <span class="arithmatex">\(x\)</span>
:::
:::</p>
<p>::: algorithm
[List-Insert']{.smallcaps} <span class="arithmatex">\((L,x)\)</span></p>
<p>::: algorithmic
<span class="arithmatex">\(x\,.\,next = L\,.\,nil\,.\,next\)</span> <span class="arithmatex">\(L\,.\,nil\,.\,next\,.\,prev = x\)</span>
<span class="arithmatex">\(L\,.\,nil\,.\,next = x\)</span> <span class="arithmatex">\(x\,.\,prev = L\,.\,nil\)</span>
:::
:::</p>
<p>::: algorithm
[List-Delete']{.smallcaps} <span class="arithmatex">\((L,x)\)</span></p>
<p>::: algorithmic
<span class="arithmatex">\(x\,.\,prev\,.\,next = x\,.\,next\)</span> <span class="arithmatex">\(x\,.\,next\,.\,prev = x\,.\,prev\)</span>
:::
:::</p>
<p>Some applications of circularly linked lists are:</p>
<ul>
<li>
<p>Useful for implementation of queue.</p>
</li>
<li>
<p>Circular lists are useful in applications to repeatedly go around
    the list.</p>
</li>
<li>
<p>Circular doubly linked lists are used for implementation of advanced
    data structures like Fibonacci Heap.</p>
</li>
</ul>
<p>-3ex -0.1ex -.4ex 0.5ex .2ex Implementing Pointers and Objects We can
implement pointers and objects in languages that do not provide them by
synthesizing them from arrays and array indices. For this example, let's
use the following doubly linked list:</p>
<p>::: center
<img alt="image" src="../Figure/5/ex_lnklist1.png" width="70%" />
:::</p>
<dl>
<dt>Single-array representation of objects.</dt>
<dd>
<p>Analogous to storing an object in the memory.</p>
</dd>
</dl>
<p>::: center
<img alt="image" height="3cm" src="../Figure/5/single_arr.png" />
:::</p>
<blockquote>
<p>Each object is represented by a contiguous sub-array of length
<span class="arithmatex">\(3\)</span>. The three attributes
[<code>key</code>]{style="background-color: light-gray"},
[<code>next</code>]{style="background-color: light-gray"}, and
[<code>prev</code>]{style="background-color: light-gray"} correspond to the
offsets: <span class="arithmatex">\(0\)</span>, <span class="arithmatex">\(1\)</span>, and <span class="arithmatex">\(2\)</span> of
the sub-array.</p>
</blockquote>
<dl>
<dt>Multiple-array representation of objects.</dt>
<dd>
<p>We can represent a collection of objects that have the same
attributes by using an array for each attribute.</p>
</dd>
</dl>
<p>::: center
<img alt="image" height="3cm" src="../Figure/5/mult_arr.png" />
:::</p>
<blockquote>
<p>You can think of each column (or vertical slice) as a single object.
The pointers resides in the
[<code>next</code>]{style="background-color: light-gray"} and
[<code>prev</code>]{style="background-color: light-gray"} array, which point to
the index where the next object resides.</p>
</blockquote>
<dl>
<dt>Allocating and freeing objects.</dt>
<dd>
<p>To insert a key into a dynamic set represented by a doubly linked
list, we must allocate a pointer to a currently unused object in the
linked-list representation.</p>
</dd>
</dl>
<p>::: center
<img alt="image" src="../Figure/5/ex_lnklist2.png" width="\textwidth" />
:::</p>
<blockquote>
<p>We keep the free objects in a singly linked list (only
[<code>next</code>]{style="background-color: light-gray"} pointer), which we call
the free list. The free list acts like a stackthe next object
allocated is the last one freed.</p>
</blockquote>
<p>-4ex -1ex -.4ex 1ex .2ex Heaps The (binary) heap data structure is an
array of object that we can view as a nearly complete binary tree. Each
node of the tree corresponds to an element of the array.</p>
<p>::: center
<img alt="image" height="4cm" src="../Figure/5/heap.png" />
:::</p>
<p>There are two kinds of binary heap. In both kinds, the values in the
nodes satisfy a heap property, the specifics of which depend on the kind
of heap.</p>
<dl>
<dt>Max-heap.</dt>
<dd>
<p>The max-heap property is that for every node <span class="arithmatex">\(i\)</span> other
than the root: <span class="arithmatex">\(<span class="arithmatex">\(A[\textsc{Parent}(i)] \geq A[i]\)</span>\)</span>
which means that a child node can't have a greater value than its
parent.</p>
</dd>
<dt>Min-heap.</dt>
<dd>
<p>The min-heap property is the opposite, which for every node
<span class="arithmatex">\(i\)</span> other than the root:
<span class="arithmatex">\(<span class="arithmatex">\(A[\textsc{Parent}(i)] \leq A[i]\)</span>\)</span> which means that a
parent node can't have a greater value than its child nodes.</p>
</dd>
</dl>
<p>If all the nodes satisfy the heap property, then a binary tree is a
heap. However, if a node does not have the heap property, the node is
swapped with the parent. This operation is called sifting up.</p>
<p>::: center
<img alt="image" src="../Figure/5/heap_sift.png" width="\textwidth" />
:::</p>
<p>-3ex -0.1ex -.4ex 0.5ex .2ex Constructing a Heap A heap can be stored as
an array <span class="arithmatex">\(A\)</span>, where the:</p>
<ul>
<li>
<p>Root of tree is <span class="arithmatex">\(A[1]\)</span>. The cell at index
    <span class="arithmatex">\(0\)</span> is not used, thus we start at index
    <span class="arithmatex">\(1\)</span>.</p>
</li>
<li>
<p>Parent of <span class="arithmatex">\(A[i]\)</span> is
    <span class="arithmatex">\(A[\lfloor i/2 \rfloor]\)</span>.</p>
</li>
<li>
<p>Left child of <span class="arithmatex">\(A[i]\)</span> is <span class="arithmatex">\(A[2i]\)</span>.</p>
</li>
<li>
<p>Right child of <span class="arithmatex">\(A[i]\)</span> is <span class="arithmatex">\(A[2i + 1]\)</span>.</p>
</li>
</ul>
<p>To construct a heap:</p>
<ol>
<li>
<p>Start with a single node.</p>
</li>
<li>
<p>Add a node to the right of the rightmost node in the deepest level.
    If the deepest level is full, start a new level.</p>
</li>
<li>
<p>Each time we add a node, we may destroy heap property of its parent
    node. To fix this, sift up until either:</p>
<ul>
<li>
<p>We reach nodes whose values don't need to be swappedthe parent
    node is larger than both children.</p>
</li>
<li>
<p>We reach the root.</p>
</li>
</ul>
</li>
</ol>
<p>Suppose we have an array <span class="arithmatex">\(A = [8, 10, 5, 12, 14]\)</span>, we would
construct the heap as such:</p>
<p>::: center
<img alt="image" src="../Figure/5/heap_const1.png" width="90%" />
<img alt="image" src="../Figure/5/heap_const2.png" width="\textwidth" />
<img alt="image" src="../Figure/5/heap_const3.png" width="\textwidth" />
:::</p>
<p>Our final heap should look like this:</p>
<p>::: center
<img alt="image" height="3.5cm" src="../Figure/5/heap_const4.png" />
:::</p>
<p>-3ex -0.1ex -.4ex 0.5ex .2ex Maintaining Heap Property To implement
this:</p>
<ol>
<li>
<p>Represent an arbitrary array as a binary tree.</p>
</li>
<li>
<p>Devise a [<code>Max-Heapify()</code>]{style="background-color: light-gray"}
    algorithm that maintains the heap property of any given node
    <span class="arithmatex">\(i\)</span> in the heap with sub-trees <span class="arithmatex">\(l\)</span> and
    <span class="arithmatex">\(r\)</span> rooted at <span class="arithmatex">\(i\)</span>th children, given to be
    heaps.</p>
</li>
<li>
<p>Devise a [<code>Build-Max-Heap()</code>]{style="background-color: light-gray"}
    algorithm that uses
    [<code>Max-Heapify()</code>]{style="background-color: light-gray"} algorithm to
    construct a heap.</p>
</li>
</ol>
<p>::: algorithm
[Max-Heapify]{.smallcaps} <span class="arithmatex">\((A,n)\)</span></p>
<p>::: algorithmic
:::
:::</p>
<p>::: algorithm
[Build-Max-Heap]{.smallcaps} <span class="arithmatex">\((A)\)</span></p>
<p>::: algorithmic
:::
:::</p>
<p>The worst-case time complexity of:</p>
<ul>
<li>
<p>[Max-Heapify]{.smallcaps} is <span class="arithmatex">\(\text{O}(\log{n})\)</span></p>
</li>
<li>
<p>[Build-Max-Heap]{.smallcaps} is <span class="arithmatex">\(\text{O}(n)\)</span></p>
</li>
</ul>
<p>The heapsort algorithm is based on the heap data structure, which uses
these two main parts: building a max-heap and sorting it, to sort</p>
<p>::: algorithm
[Heapsort]{.smallcaps} <span class="arithmatex">\((A)\)</span></p>
<p>::: algorithmic
:::
:::</p>
<p>Thus, heapsort has a worst-case time complexity of
<span class="arithmatex">\(\text{O}(n\log{n})\)</span> like merge sort, but heapsort has a
space complexity of <span class="arithmatex">\(\text{O}(1)\)</span>, since it sorts in-place,
taking a constant amount of memory.</p>
<p>-3ex -0.1ex -.4ex 0.5ex .2ex Priority Queue One of the most popular
implementations of a heap, a priority queue is a data structure for
maintaining a set <span class="arithmatex">\(S\)</span> of elements, each with an associated
value called a key. As with heaps, there are two kinds of priority
queues: max-priority queue and min-priority queue.</p>
<p>::: center
<img alt="image" src="../Figure/5/prior_queue.png" width="\textwidth" />
:::</p>
<p>We will focus here on how to implement max-priority queues, which are in
turn based on max-heaps. A max-priority queue supports dynamic-set
operations:</p>
<ul>
<li>
<p>[<code>Insert(S,x)</code>]{style="background-color: light-gray"} - Inserts
    element [<code>x</code>]{style="background-color: light-gray"} into set
    [<code>S</code>]{style="background-color: light-gray"}.</p>
</li>
<li>
<p>[<code>Maximum(S)</code>]{style="background-color: light-gray"} - Returns an
    element of [<code>S</code>]{style="background-color: light-gray"} with largest
    key.</p>
</li>
<li>
<p>[<code>Extract-Max(S)</code>]{style="background-color: light-gray"} - Removes
    and returns element of [<code>S</code>]{style="background-color: light-gray"}
    with largest key.</p>
</li>
<li>
<p>[<code>Increase-Key(S,x,k)</code>]{style="background-color: light-gray"} -
    Increases value of element
    [<code>x</code>]{style="background-color: light-gray"}'s key to
    [<code>k</code>]{style="background-color: light-gray"}. Assume
    [<code>k \geq x</code>]{style="background-color: light-gray"}'s current key
    value.</p>
</li>
</ul>
<p>The procedure [Heap-Maximum]{.smallcaps} has a running time of
<span class="arithmatex">\(\Theta(1)\)</span>.</p>
<p>::: algorithm
[Heap-Maximum]{.smallcaps} <span class="arithmatex">\((A)\)</span></p>
<p>::: algorithmic
:::
:::</p>
<p>The procedure [Heap-Extract-Max]{.smallcaps} has a running time of
<span class="arithmatex">\(\text{O}(\log{n})\)</span>.</p>
<p>::: algorithm
[Heap-Extract-Max]{.smallcaps} <span class="arithmatex">\((A)\)</span></p>
<p>::: algorithmic
:::
:::</p>
<p>The procedure [Heap-Increase-Key]{.smallcaps} has a running time of
<span class="arithmatex">\(\text{O}(\log{n})\)</span>.</p>
<p>::: algorithm
[Heap-Increase-Key]{.smallcaps} <span class="arithmatex">\((A,i,key)\)</span></p>
<p>::: algorithmic
:::
:::</p>
<p>The procedure [Max-Heap-Insert]{.smallcaps} has a running time of
<span class="arithmatex">\(\text{O}(\log{n})\)</span>.</p>
<p>::: algorithm
[Max-Heap-Insert]{.smallcaps} <span class="arithmatex">\((A,key)\)</span></p>
<p>::: algorithmic
:::
:::</p>
<p>In summary, a heap can support any priority-queue operation on a set of
size <span class="arithmatex">\(n\)</span> in <span class="arithmatex">\(\text{O}(\log{n})\)</span> time.</p>
<h1 id="hash-tables">Hash Tables<a class="headerlink" href="#hash-tables" title="Permanent link">&para;</a></h1>
<p>-4ex -1ex -.4ex 1ex .2ex Introduction Many applications require a
dynamic set that supports only the dictionary operations.</p>
<p>::: dBox
::: definitionT
<strong>Definition 6.1</strong> (Dictionary). <em>A data structure that stores (key,
value) pairs and supports the operations [Insert]{.smallcaps},
[Search]{.smallcaps}, and [Delete]{.smallcaps}.</em>
:::
:::</p>
<p>So far we have seen a couple ways to implement dictionaries, such as
linked lists. Now we will learn how to use a hash tables.</p>
<p>-3ex -0.1ex -.4ex 0.5ex .2ex How It Works? A hash tables takes a key
(typically a string of characters or numbers) and passes it through a
hash function to convert it into an index of the array to store the
associated value.</p>
<p>::: center
<img alt="image" height="3cm" src="../Figure/6/hash_table1.png" />
:::</p>
<p>Suppose you need to find a value of the key, you do not need to iterate
through all items in the collection, because you can just use the hash
function to easily find the index.</p>
<ul>
<li>
<p>Using a hash table offers a very fast lookup for a value based on
    the key, which should be the <span class="arithmatex">\(\text{O}(1)\)</span> operation.</p>
</li>
<li>
<p>It is a generalization of an ordinary array.</p>
</li>
</ul>
<p>-3ex -0.1ex -.4ex 0.5ex .2ex Sample Problem As an example, you can think
of a phone book. In the phone book, a person's name can be considered as
a key, by which we can find a phone number.</p>
<dl>
<dt>Case One:</dt>
<dd>
<p>The simple and straightforward way to lookup number is to check all
names in the phone book until we find a matching name. The
worst-case search time is <span class="arithmatex">\(\text{O}(n)\)</span>.</p>
</dd>
<dt>Case Two:</dt>
<dd>
<p>Use a hash function that helps us to lookup entries much faster.</p>
</dd>
</dl>
<p>Suppose we have a person's name \"James Davis\" with the phone number
\"416-999-1234\". A hash function takes the key and maps it to an
integer that is within the size of the array:
<span class="arithmatex">\(<span class="arithmatex">\(\text{String}\ \Rightarrow\ \boxed{\text{Hash Function}}\ \Rightarrow\ \text{Index}\)</span>\)</span>
Then it stores the value of the phone number to an index of the array.
If we continue to add more people, it would map each one to an index of
the array.</p>
<p>::: center
<img alt="image" height="4cm" src="../Figure/6/ex_hash.png" />
:::</p>
<p>If we wanna lookup a person's phone number, all we need is the person's
name and we can easily find the index it is stored in the array, by
passing it through a hash function.</p>
<p>Obviously, this is a watered-down explanation and doesn't go
in-depthlike the possibility when two or more keys hash to the same
slot. But before moving further, let's understand how direct-address
table works to see the benefits of using hash tables instead.</p>
<p>-3ex -0.1ex -.4ex 0.5ex .2ex Direct Address Table With an ordinary
array, we store element whose key is <span class="arithmatex">\(k\)</span> in position
<span class="arithmatex">\(k\)</span> of the array.</p>
<p>::: center
<img alt="image" height="5cm" src="../Figure/6/dat_table1.png" />
:::</p>
<p>::: dBox
::: definitionT
<strong>Definition 6.2</strong> (Direct addressing). <em>Given a key <span class="arithmatex">\(k\)</span>,
we find the element whose key is <span class="arithmatex">\(k\)</span> by just looking in the
<span class="arithmatex">\(k\)</span>th position of the array.</em>
:::
:::</p>
<p>A direct-address table (DAT) uses the keys as indices of the array and
stores the values at those bucket locations.</p>
<p>::: center
<img alt="image" height="4cm" src="../Figure/6/ex_dat.png" />
:::</p>
<p>It does facilitate fast searching, fast inserting and fast deletion
operations:</p>
<ul>
<li>
<p>Inserting or deleting an element in the table, is the same as you
    would do for an array, hence we can do that in
    <span class="arithmatex">\(\text{O}(1)\)</span> time as we already know the index (via
    key).</p>
</li>
<li>
<p>Searching an element takes <span class="arithmatex">\(\text{O}(1)\)</span> times, as we
    can easily access an element in an array in linear time if we
    already know the index of that element.</p>
</li>
</ul>
<p>Direct addressing is applicable when we can afford to allocate an array
with one position for every possible key, and so it comes at a cost:</p>
<ul>
<li>
<p>It cannot handle collisionstwo keys are equal and contain different
    values.</p>
</li>
<li>
<p>It is not recommended using the direct address table if the key
    values are very large.</p>
</li>
</ul>
<p>It has serious disadvantages, making it not suitable for the practical
usage of current world scenarios, which is why we make use of hash
tables.</p>
<p>-3ex -0.1ex -.4ex 0.5ex .2ex Hash Table As a recap, from the
introduction, instead of storing an element with key <span class="arithmatex">\(k\)</span> in
index <span class="arithmatex">\(k\)</span>, we use a hash function <span class="arithmatex">\(h\)</span> and
store the element in index <span class="arithmatex">\(h(k)\)</span>.</p>
<p>::: center
<img alt="image" height="5cm" src="../Figure/6/hash_table2.png" />
:::</p>
<p>::: dBox
::: definitionT
<strong>Definition 6.3</strong> (Hash function). <em>A hash function <span class="arithmatex">\(h\)</span>
maps all possible keys to the slots of an array
<span class="arithmatex">\(T[0 \dots n - 1]\)</span>.</em>
:::
:::</p>
<p>While hash table offer the same time complexity of
<span class="arithmatex">\(\text{O}(1)\)</span> when we talk about insertion, deletion, or
searching an element, the main focus is in its ability to maintains the
size constraint.</p>
<p>The problem with DAT is if the universe <span class="arithmatex">\(U\)</span> of keys is
large, storing a table of size of <span class="arithmatex">\(|U|\)</span> may be impractical
or impossible. Often, the set of keys <span class="arithmatex">\(K\)</span> actually stored
is small, compared to <span class="arithmatex">\(U\)</span>.</p>
<p>::: problem
<strong>Problem 6.1</strong>. <em>Suppose we have a key of <span class="arithmatex">\(7898\)</span>, which in
turn is a large number.</em>
:::</p>
<dl>
<dt>Case One:</dt>
<dd>
<p>Using a DAT table, we would need a huge array, for the key in index
<span class="arithmatex">\(7898\)</span> to store the value at <span class="arithmatex">\(T[7898]\)</span>. In
turn, we are wasting too much space, as most of the allocated space
for the array is wasted.</p>
</dd>
<dt>Case Two:</dt>
<dd>
<p>But, in the case of a hash table, we can process this key via a hash
function. The hash function <span class="arithmatex">\(h(7898)\)</span> maps it to an
index within the hash table <span class="arithmatex">\(T[0 \dots n - 1]\)</span>.</p>
</dd>
</dl>
<p>Regarding the size of the hash table <span class="arithmatex">\(n\)</span> it typically
varies, as it depends in part on choice of the hash function and
collision resolution, where a situation might arise when two or more
keys hash to the same slot.</p>
<p>-4ex -1ex -.4ex 1ex .2ex Hash Function A good hash function should
minimizes collision as mush as possible. It is usually specified as the
composition of two functions <span class="arithmatex">\(h(k) = h_2\big(h_1(k)\big)\)</span>:</p>
<dl>
<dt>Hash code.</dt>
<dd>
<p><span class="arithmatex">\(h_1: \text{keys}\ \to\ \text{integers}\)</span></p>
</dd>
<dt>Compression function.</dt>
<dd>
<p><span class="arithmatex">\(h_2: \text{integers}\ \to\ [0 \dots n - 1]\)</span></p>
</dd>
</dl>
<p>::: center
<img alt="image" height="4cm" src="../Figure/6/hash_func.png" />
:::</p>
<p>The goal of the hash function is to disperse the keys in an apparently
random way.</p>
<p>-3ex -0.1ex -.4ex 0.5ex .2ex Hash Code As mentioned previously, keys can
be a string of characters. Thus, if the keys are not natural numbers, we
find a way to interpret them as natural numbers. Some popular hash code
maps are:</p>
<dl>
<dt>Summing hash code.</dt>
<dd>
<p>By adding up the <a href="https://www.cs.cmu.edu/~pattis/15-1XX/common/handouts/ascii.html">[ASCII
values]{.underline}</a>
of each letters in a string, we get an integer in return. For
example, if the key is \"stop\":
<span class="arithmatex">\(<span class="arithmatex">\(h_1("stop") = 115 + 116 + 111 + 112\)</span>\)</span> However, this
is not suitable for strings cause two different strings can have the
same set of letters, but have different meaning\"post\", \"tops\",
and \"pots\" will have the same hash code.</p>
</dd>
<dt>Polynomial hash code.</dt>
<dd>
<p>A better hash code takes into account the position of each
character. Using the example from before:
<span class="arithmatex">\(<span class="arithmatex">\(h_1("stop") = (115 \times a^0) + (116 \times a^1) + (111 \times a^2) + (112 \times a^3)\)</span>\)</span>
where <span class="arithmatex">\(a\)</span> is a non-zero constantcompared to \"post\",
\"tops\", and \"pots\", all have unique hash codes, which is ideal.</p>
</dd>
</dl>
<p>-3ex -0.1ex -.4ex 0.5ex .2ex Compression Function The hash code
typically returns a large range of integers and so the compression
functions maps it in the range <span class="arithmatex">\([0 \dots n - 1]\)</span>, the
indices of the hash table. There's two methods:</p>
<dl>
<dt>Division Method.</dt>
<dd>
<p>A simple-modulo based compression rule:
<span class="arithmatex">\(<span class="arithmatex">\(h_2(k) = k\ \text{mod}\ n\)</span>\)</span> The size <span class="arithmatex">\(n\)</span>
of the hash table is usually chosen to be a prime number, to help
spread out the distribution of hash values.</p>
</dd>
<dt>MAD Method.</dt>
<dd>
<p>The Multiply-Add-Divide method still use
<span class="arithmatex">\(\text{mod}\ n\)</span> to get the numbers in the range, but a
little fancier by spreading the numbers out first:
<span class="arithmatex">\(<span class="arithmatex">\(h_2(k) = [(ak + b)\ \text{mod}\ p]\ \text{mod}\ n\)</span>\)</span>
The values <span class="arithmatex">\(a\)</span> and <span class="arithmatex">\(b\)</span> are chosen at
random as positive integers and <span class="arithmatex">\(p\)</span> is a prime number,
where <span class="arithmatex">\(p &gt; n\)</span>. With the addition of
<span class="arithmatex">\((ak + b)\ \text{mod}\ p\)</span>, it eliminates patterns
provided by <span class="arithmatex">\(k\ \text{mod}\ n\)</span>.</p>
</dd>
</dl>
<p>Both incorporate the modulo operator, as it guarantees the output to be
within the size of the hash table. Suppose we have a key of
<span class="arithmatex">\(7898\)</span> from the previous example and a hash table with
<span class="arithmatex">\(23\)</span> slots:
<span class="arithmatex">\(<span class="arithmatex">\(h_2(7898) = 7898\ \text{mod}\ 23 = 9\)</span>\)</span> Then the key will
be mapped to index <span class="arithmatex">\(9\)</span> of the hash table.</p>
<p>-4ex -1ex -.4ex 1ex .2ex Collision Handling Collision occurs when
different elements are mapped to the same index of the arraywhen
<span class="arithmatex">\(h(k_1) = h(k_2)\)</span>, but <span class="arithmatex">\(k_1 \neq k_2\)</span>.</p>
<p>::: center
<img alt="image" height="4cm" src="../Figure/6/hash_table3.png" />
:::</p>
<p>Avoiding collision is ideal, nonetheless, it is impossible, so we use
closed or open addressing to overcome this problem. Each of them have
their pros and cons.</p>
<p>-3ex -0.1ex -.4ex 0.5ex .2ex Closed Addressing Closed addressing (or
open hashing) is also known as separate chaining.</p>
<p>When collision occurs, the index keeps a reference to a linked list or
dynamic array that stores all items with the same index. Let
<span class="arithmatex">\(e_1\)</span> and <span class="arithmatex">\(e_2\)</span> represent the values attached
to <span class="arithmatex">\(k_1\)</span> and <span class="arithmatex">\(k_2\)</span> respectively.</p>
<p>::: center
<img alt="image" height="4cm" src="../Figure/6/c_chaining.png" />
:::</p>
<p>Separate chaining is fairly simple to implement and faster than open
addressing in general. However, it is memory inefficient as it requires
a secondary data structure and longs chains can result in
<span class="arithmatex">\(\text{O}(n)\)</span> times.</p>
<p>-3ex -0.1ex -.4ex 0.5ex .2ex Open Addressing Instead of referencing to a
list or an array, open addressing (or closed hashing) resolves collision
by searching for another empty bucket.</p>
<p>::: center
<img alt="image" height="4cm" src="../Figure/6/c_linprob.png" />
:::</p>
<p>There's three types of open addressing:</p>
<dl>
<dt>Linear Probing.</dt>
<dd>
<p>When collision occurs, we linearly probe for the next bucket by
increasing the index linearly until it finds an empty bucket:
<span class="arithmatex">\(<span class="arithmatex">\(\text{Index} = \big[h(k) + i\big]\ \text{mod}\ n\)</span>\)</span>
where <span class="arithmatex">\(i\)</span> increases by one each iteration, until it
finds an empty bucket.</p>
</dd>
<dt>Quadratic Probing.</dt>
<dd>
<p>Similar to the previous one, but instead we increase the index
quadratically until it finds an empty bucket:
<span class="arithmatex">\(<span class="arithmatex">\(\text{Index} = \big[h(k) + i^2\big]\ \text{mod}\ n\)</span>\)</span>
where <span class="arithmatex">\(i\)</span> increases by one each iteration, until it
finds an empty bucket.</p>
</dd>
<dt>Double Hashing.</dt>
<dd>
<p>Using a secondary hash function <span class="arithmatex">\(h'(k)\)</span>, it places the
colliding item in the first available cell by:
<span class="arithmatex">\(<span class="arithmatex">\(\text{Index} = \big[h(k) + jh'(k)\big]\ \text{mod}\ n\)</span>\)</span>
where <span class="arithmatex">\(j\)</span> increases by one each iteration, until it
finds an empty bucket. The secondary hash function cannot have zero
values and is typically written as such:
<span class="arithmatex">\(<span class="arithmatex">\(h'(k) = q -(k\ \text{mod}\ q)\)</span>\)</span> where
<span class="arithmatex">\(q\)</span> is a prime number, such that <span class="arithmatex">\(q &gt; n\)</span>.</p>
</dd>
</dl>
<p>Unlike separate chaining, open addressing is more memory efficient, as
it stores element in empty indices. However, it can create cluster:</p>
<ul>
<li>
<p>Linear probing can result in primary clustering.</p>
</li>
<li>
<p>Quadratic probing can result in secondary clustering.</p>
</li>
</ul>
<p>Compared to the two, double hashing distributes the keys more evenly and
produces a uniform distribution of records throughout the hash table.</p>
<h1 id="trees">Trees<a class="headerlink" href="#trees" title="Permanent link">&para;</a></h1>
<p>-4ex -1ex -.4ex 1ex .2ex Introduction A tree is a dynamic set of nodes
storing elements in a parent-child relationship (edge) with the
following properties:</p>
<ul>
<li>
<p>It has a special node called root.</p>
</li>
<li>
<p>Each node different from the root has a parent node.</p>
</li>
<li>
<p>There is a single unique path along the edges from the root to any
    particular nodedoesn't have any cycles.</p>
</li>
</ul>
<p>::: center
<img alt="image" height="3cm" src="../Figure/7/tree_org.png" />
:::</p>
<p>-3ex -0.1ex -.4ex 0.5ex .2ex Tree Terminology In a tree, we often refer
to certain parts of tree, which are listed below. For reference:</p>
<p>::: center
<img alt="image" height="4cm" src="../Figure/7/tree_term.png" />
:::</p>
<ul>
<li>
<p>Root: The top element with no parent (<span class="arithmatex">\(A\)</span>).</p>
</li>
<li>
<p>Siblings: Children of the same parent (<span class="arithmatex">\(G, H\)</span> both have
    the parent <span class="arithmatex">\(C\)</span>).</p>
</li>
<li>
<p>External node: Also referred to as leave, ndoes with no children
    (<span class="arithmatex">\(E, I, J, K, G, H\)</span>).</p>
</li>
<li>
<p>Internal node: nodes with one or more children
    (<span class="arithmatex">\(A, B, C, F\)</span>).</p>
</li>
<li>
<p>Ancestors: A node that is connected to all lower-level node
    (<span class="arithmatex">\(A, B, F\)</span> are ancestors of <span class="arithmatex">\(I, J, K\)</span>).</p>
</li>
<li>
<p>Descendants: The connected lower-level nodes (<span class="arithmatex">\(I\)</span> is a
    descendant of <span class="arithmatex">\(A, B, F\)</span>).</p>
</li>
<li>
<p>Depth of a node: Number of ancestors (<span class="arithmatex">\(I\)</span> has a depth
    of <span class="arithmatex">\(3\)</span>).</p>
</li>
<li>
<p>Height of a tree: The max node depth (The height of tree is
    <span class="arithmatex">\(3\)</span>).</p>
</li>
<li>
<p>Sub-tree: A tree consisting of a node and all its descendants (Refer
    to the red triangle above).</p>
</li>
</ul>
<p>-3ex -0.1ex -.4ex 0.5ex .2ex Tree Traversals A traversal is defined as a
systematic way of accessing or visiting all nodes of a tree. Let's use
the following tree as an example:</p>
<p>::: center
<img alt="image" height="3cm" src="../Figure/7/tree.png" />
:::</p>
<p>There's three ways a tree can be traverse, but we'll only go over two of
them. The last one will be covered in the next section.</p>
<dl>
<dt>Preorder traversal.</dt>
<dd>
<p>Root is visited first and then sub-trees rooted at its children are
visited recursively
(<span class="arithmatex">\(A \to B \to D \to E \to C \to F \to G\)</span>).</p>
</dd>
<dt>Postorder traversal.</dt>
<dd>
<p>Recursively traverse the sub-trees rooted at children and then visit
the root itself
(<span class="arithmatex">\(D \to E \to F \to G \to B \to C \to A\)</span>).</p>
</dd>
</dl>
<p>-4ex -1ex -.4ex 1ex .2ex Binary Search Tree Search trees are designed to
support efficient search operations, including [Search]{.smallcaps},
[Minimum]{.smallcaps}, [Maximum]{.smallcaps}, [Predecessor]{.smallcaps},
[Successor]{.smallcaps}, [Insert]{.smallcaps}, and [Delete]{.smallcaps}.</p>
<p>A binary tree is a tree with the following:</p>
<ul>
<li>
<p>Each internal node has at most two children.</p>
</li>
<li>
<p>The children of a node are an ordered pairleft child, right child
    and left sub-tree, right sub-tree.</p>
</li>
<li>
<p>The keys satisfy the binary-search tree property:
    <span class="arithmatex">\(u.key \leq v.key \leq w.key\)</span></p>
<ul>
<li>
<p>Node <span class="arithmatex">\(u\)</span> is a node (any node) in the left sub-tree
    of node <span class="arithmatex">\(v\)</span>.</p>
</li>
<li>
<p>Node <span class="arithmatex">\(w\)</span> is a node (any node) in the right sub-tree
    of node <span class="arithmatex">\(v\)</span>.</p>
</li>
</ul>
</li>
</ul>
<p>::: center
<img alt="image" height="3cm" src="../Figure/7/bst.png" />
:::</p>
<p>In other words, the value of the key of the parent should be between the
value of the key of the left child and right child.</p>
<p>A binary search tree (BST) is organized, as the name suggests, in a
binary tree, where [<code>root[T]</code>]{style="background-color: light-gray"}
points to the root of tree [<code>T</code>]{style="background-color: light-gray"}
and each node contains the fields:</p>
<ul>
<li>
<p>[<code>key</code>]{style="background-color: light-gray"} (and possibly other
    satellite data)</p>
</li>
<li>
<p>[<code>left</code>]{style="background-color: light-gray"} which points to left
    child.</p>
</li>
<li>
<p>[<code>right</code>]{style="background-color: light-gray"} which points to
    right child.</p>
</li>
<li>
<p>[<code>p</code>]{style="background-color: light-gray"} which points to parent,
    where [<code>p[root[T]] = nil</code>]{style="background-color: light-gray"}</p>
</li>
</ul>
<p>-3ex -0.1ex -.4ex 0.5ex .2ex Inorder Traversal The binary-search tree
property allows us to print out all the keys in sorted tree by a simple
recursive algorithm, called an inorder tree walk, which can be
visualized as such:</p>
<p>::: center
<img alt="image" height="3.5cm" src="../Figure/7/in_order1.png" />
:::</p>
<p><span class="arithmatex">\(<span class="arithmatex">\(D \to B \to E \to A \to F \to C \to G\)</span>\)</span> How
[Inorder-Tree-Walk]{.smallcaps} works:</p>
<ol>
<li>
<p>Check to make sure that [<code>x</code>]{style="background-color: light-gray"}
    is not [<code>nil</code>]{style="background-color: light-gray"}.</p>
</li>
<li>
<p>Recursively, print the keys of the nodes in the
    [<code>x</code>]{style="background-color: light-gray"}'s left sub-tree.</p>
</li>
<li>
<p>Print [<code>x</code>]{style="background-color: light-gray"}'s key.</p>
</li>
<li>
<p>Recursively, print the keys of the nodes in the
    [<code>x</code>]{style="background-color: light-gray"}'s right sub-tree.</p>
</li>
</ol>
<p>::: algorithm
[Inorder-Tree-Walk]{.smallcaps} <span class="arithmatex">\((x)\)</span></p>
<p>::: algorithmic
:::
:::</p>
<p>-3ex -0.1ex -.4ex 0.5ex .2ex Querying Binary search tree can support
such queries as [Search]{.smallcaps}, [Minimum]{.smallcaps},
[Maximum]{.smallcaps}, [Predecessor]{.smallcaps}, and
[Successor]{.smallcaps} operations.</p>
<p>The [Tree-Search]{.smallcaps} procedure starts at the root and traces a
simple path downward in the tree. The running time is
<span class="arithmatex">\(\text{O}(h)\)</span>, where <span class="arithmatex">\(h\)</span> is the height of the
tree.</p>
<p>::: algorithm
[Tree-Search]{.smallcaps} <span class="arithmatex">\((x,k)\)</span></p>
<p>::: algorithmic
:::
:::</p>
<p>The [Iterative-Tree-Search]{.smallcaps} is more efficient in which works
by \"unrolling\" the recursion into a while loop.</p>
<p>::: algorithm
[Tree-Search]{.smallcaps} <span class="arithmatex">\((x,k)\)</span></p>
<p>::: algorithmic
:::
:::</p>
<p>Refer to the diagram below:</p>
<p>::: center
<img alt="image" height="4cm" src="../Figure/7/binary_search.png" />
:::</p>
<p>The binary search-tree property guarantees that:</p>
<ul>
<li>
<p>the leftmost node is the minimum key of the binary search tree</p>
</li>
<li>
<p>the rightmost node is the maximum key of the binary search tree</p>
</li>
</ul>
<p>Thus, the [Tree-Minimum]{.smallcaps} and [Tree-Maximum]{.smallcaps}
procedure traverse the appropriate points until [nil]{.smallcaps} is
reached. The running time for both is <span class="arithmatex">\(\text{O}(h)\)</span>.</p>
<p>::: algorithm
[Tree-Minimum]{.smallcaps} <span class="arithmatex">\((x)\)</span></p>
<p>::: algorithmic
:::
:::</p>
<p>::: algorithm
[Tree-Maximum]{.smallcaps} <span class="arithmatex">\((x)\)</span></p>
<p>::: algorithmic
:::
:::</p>
<p>Refer to the diagram below:</p>
<p>::: center
<img alt="image" height="4cm" src="../Figure/7/binary_minmax.png" />
:::</p>
<p>Before going over the procedure for successor and predecessor, let's
define what it means. Assuming all keys are unique, if <span class="arithmatex">\(x\)</span>
has two children:</p>
<ul>
<li>
<p>The successor is the minimum value in its right sub-tree.</p>
</li>
<li>
<p>The predecessor is the maximum value in its left sub-tree.</p>
</li>
</ul>
<p>Refer to this example using the key value of <span class="arithmatex">\(25\)</span>:</p>
<p>::: center
<img alt="image" height="4cm" src="../Figure/7/predecessor_succesor1.png" />
:::</p>
<p>If you recall from earlier, when we performed inorder traversal, we can
find the successor and predecessor based entirely on the tree structure.</p>
<p>::: algorithm
[Tree-Successor]{.smallcaps} <span class="arithmatex">\((x)\)</span></p>
<p>::: algorithmic
:::
:::</p>
<p>We can break the code for [Tree-Successor]{.smallcaps} into two cases:</p>
<ol>
<li>
<p>If [<code>x.right</code>]{style="background-color: light-gray"} is non-empty,
    then [<code>x</code>]{style="background-color: light-gray"}'s successor is the
    minimum in [<code>x</code>]{style="background-color: light-gray"}'s right
    sub-tree.</p>
</li>
<li>
<p>If [<code>x.right</code>]{style="background-color: light-gray"} is empty, then
    go up the tree until the current node is a left child. If you cannot
    go up further and you reached root, then
    [<code>x</code>]{style="background-color: light-gray"} is the largest element.</p>
</li>
</ol>
<p>For example, if we want to find the successor of the key value of
<span class="arithmatex">\(20\)</span>:</p>
<ol>
<li>
<p>The right sub-tree is empty, so we go up the tree to the key value
    of <span class="arithmatex">\(19\)</span>.</p>
</li>
<li>
<p>Since <span class="arithmatex">\(20\)</span> is not a left child or located in the left
    sub-tree of <span class="arithmatex">\(19\)</span>, go up the tree to the key value of
    <span class="arithmatex">\(15\)</span>.</p>
</li>
<li>
<p>Likewise, it is not a left child of <span class="arithmatex">\(15\)</span>, so go up the
    tree to the key value of <span class="arithmatex">\(25\)</span>.</p>
</li>
<li>
<p>The key value of <span class="arithmatex">\(25\)</span> has <span class="arithmatex">\(20\)</span> as a left
    child, therefore, the successor of <span class="arithmatex">\(20\)</span> is
    <span class="arithmatex">\(25\)</span>.</p>
</li>
</ol>
<p>Refer to the diagram below:</p>
<p>::: center
<img alt="image" src="../Figure/7/predecessor_succesor2.png" width="\textwidth" />
:::</p>
<p>The [Tree-Predecessor]{.smallcaps} procedure is symmetric to
[Tree-Predecessor]{.smallcaps} procedure, which instead uses
[<code>x.left</code>]{style="background-color: light-gray"}. The running time for
both is <span class="arithmatex">\(\text{O}(h)\)</span>.</p>
<p>-3ex -0.1ex -.4ex 0.5ex .2ex Insertion and Deletion The operations of
insertion and deletion cause the dynamic set represented by a binary
search tree to change. Thus, the binary-search tree property must hold
after this change.</p>
<p>The [Tree-Insert]{.smallcaps} procedure works quite similar to
[Tree-Search]{.smallcaps} and [Iterative-Tree-Search]{.smallcaps}, which
begins at the root of the tree.</p>
<p>::: algorithm
[Tree-Insert]{.smallcaps} <span class="arithmatex">\((T,z)\)</span></p>
<p>::: algorithmic
:::
:::</p>
<p>In the code, we are trying to insert
[<code>z</code>]{style="background-color: light-gray"} to the tree
[<code>T</code>]{style="background-color: light-gray"}:</p>
<ul>
<li>
<p>The pointer [<code>x</code>]{style="background-color: light-gray"} traces a
    simple path downward looking for a [nil]{.smallcaps} to replace with
    the input [<code>z</code>]{style="background-color: light-gray"}.</p>
</li>
<li>
<p>The trailing pointer [<code>y</code>]{style="background-color: light-gray"}
    maintains the parent of [<code>x</code>]{style="background-color: light-gray"}.</p>
</li>
</ul>
<p>Suppose we want to insert an item with key <span class="arithmatex">\(9\)</span>. The while
loop in lines 3-8 can be expressed as:</p>
<p>::: center
<img alt="image" src="../Figure/7/binary_insert1.png" width="90%" />
:::</p>
<p>The [nil]{.smallcaps} occupies the position where we wish to place the
input item [<code>z</code>]{style="background-color: light-gray"}. The lines 10-15
set the pointers that cause [<code>z</code>]{style="background-color: light-gray"}
to be inserted.</p>
<p>Deletion is somewhat more tricky than insertion. The process for
deleting node [<code>z</code>]{style="background-color: light-gray"} can be broken
into three cases:</p>
<dl>
<dt>Case One:</dt>
<dd>
<p>If [<code>z</code>]{style="background-color: light-gray"} has no children, then
we simply remove it by modifying it's parent to replace
[<code>z</code>]{style="background-color: light-gray"} with [nil]{.smallcaps}.</p>
</dd>
</dl>
<p>::: center
<img alt="image" src="../Figure/7/binary_deletion1.png" width="\textwidth" />
:::</p>
<dl>
<dt>Case Two:</dt>
<dd>
<p>If [<code>z</code>]{style="background-color: light-gray"} has one child, then
delete [<code>z</code>]{style="background-color: light-gray"} by making the
parent of [<code>z</code>]{style="background-color: light-gray"} point to
[<code>z</code>]{style="background-color: light-gray"}'s child, instead of
[<code>z</code>]{style="background-color: light-gray"}.</p>
</dd>
</dl>
<p>::: center
<img alt="image" src="../Figure/7/binary_deletion2.png" width="\textwidth" />
:::</p>
<dl>
<dt>Case Three:</dt>
<dd>
<p>If [<code>z</code>]{style="background-color: light-gray"} has two children,
then delete [<code>z</code>]{style="background-color: light-gray"}'s successor,
[<code>y</code>]{style="background-color: light-gray"}, from the tree (via Case
One or Case Two) and replace
[<code>z</code>]{style="background-color: light-gray"}'s key and satellite data
with [<code>y</code>]{style="background-color: light-gray"}.</p>
</dd>
</dl>
<p>::: center
<img alt="image" src="../Figure/7/binary_deletion3.png" width="\textwidth" />
:::</p>
<p>The [Tree-Delete]{.smallcaps} procedure executes the three cases as
follows. The running time is <span class="arithmatex">\(\text{O}(h)\)</span>.</p>
<p>::: algorithm
[Tree-Delete]{.smallcaps} <span class="arithmatex">\((T,z)\)</span></p>
<p>::: algorithmic
:::
:::</p>
<p>As you may have notice, the running time for these operations:
[Search]{.smallcaps}, [Minimum]{.smallcaps}, [Maximum]{.smallcaps},
[Predecessor]{.smallcaps}, [Successor]{.smallcaps},
[Insert]{.smallcaps}, and [Delete]{.smallcaps} all take
<span class="arithmatex">\(\text{O}(h)\)</span>, where <span class="arithmatex">\(h\)</span> is the height of the
tree. These operations are fast if the height of the tree is small.</p>
<p>For binary search trees given we have <span class="arithmatex">\(n\)</span> items, the
minimum height of a binary tree can be <span class="arithmatex">\(\log{n}\)</span> and the
maximum be <span class="arithmatex">\(n\)</span>. It can be depicted as such:</p>
<p>::: center
<img alt="image" src="../Figure/7/binary_height.png" width="\textwidth" />
:::</p>
<p>Ideally we want make sure the height of the binary tree is always
<span class="arithmatex">\(\log{n}\)</span>, as it provides the worst-case running time of
<span class="arithmatex">\(\text{O}(\log{n})\)</span>, thus comes the motivation for the next
topic.</p>
<p>-3ex -0.1ex -.4ex 0.5ex .2ex Balanced Search Tree One way we can ensure
our tree is always balanced is by implementing a self-balancing binary
search tree. A search-tree data structure for which a height of
<span class="arithmatex">\(\log{n}\)</span> is guaranteed when implementing dynamic set of
<span class="arithmatex">\(n\)</span> items.</p>
<ul>
<li>
<p>AVL Tree</p>
</li>
<li>
<p>Red-Black Tree</p>
</li>
</ul>
<p>It ensures the <span class="arithmatex">\(\text{O}(\log{n})\)</span> time complexity at all
times, by maintaining the binary-search tree property and height-balance
property of the tree, whenever insertion or deletion is performed.</p>
<p>-4ex -1ex -.4ex 1ex .2ex Red-Black Trees Red-black trees are one of many
search-tree schemes that are "balanced" in order to guarantee that basic
dynamic-set operations take <span class="arithmatex">\(\text{O}(\log{n})\)</span> time in the
worst case.</p>
<p>::: center
<img alt="image" height="5cm" src="../Figure/7/br_height.png" />
:::</p>
<p>It is a binary tree that satisfies the following red-black properties:</p>
<ol>
<li>
<p>Every node is either red or black.</p>
</li>
<li>
<p>The root and leaves ([nil]{.smallcaps}) are black.</p>
</li>
<li>
<p>If a node is red, then both of its children are black.</p>
</li>
<li>
<p>For each node, all simple paths from the node to ([nil]{.smallcaps})
    descendant leaves contain the same number of black nodes.</p>
</li>
</ol>
<p>To expand more on property 4, let's find the black-height of the key
value of <span class="arithmatex">\(7\)</span>. These are all the simple paths that can be
taken indicated by the grey dashed arrow above:</p>
<ul>
<li>
<p>7, 3, [nil]{.smallcaps}</p>
</li>
<li>
<p>7, 18, 10, 8, [nil]{.smallcaps}</p>
</li>
<li>
<p>7, 18, 10, 11, [nil]{.smallcaps}</p>
</li>
<li>
<p>7, 18, 22, 26, [nil]{.smallcaps}</p>
</li>
</ul>
<p>If we don't include the root node, notice how all simple paths consists
of the (same number of) <span class="arithmatex">\(2\)</span> black nodes. Likewise, the same
can be said for every node in the tree.</p>
<p>The red-black tree is a BST, so we can implement the dynamic-set
operations [Search]{.smallcaps}, [Minimum]{.smallcaps},
[Maximum]{.smallcaps}, [Predecessor]{.smallcaps}, and
[Successor]{.smallcaps} in <span class="arithmatex">\(\text{O}(\log{n})\)</span> time.</p>
<p>-3ex -0.1ex -.4ex 0.5ex .2ex Recoloring and Rotation However, it does
not directly support the dynamic-set operations [Insert]{.smallcaps} and
[Delete]{.smallcaps}. Because they modify the tree, the result may
violate the red-black properties.</p>
<ul>
<li>
<p>We must change color of some nodes via recoloring</p>
</li>
<li>
<p>Restructure the links of the tree via rotation</p>
</li>
</ul>
<p>For starters, let's go over the relationship in a binary tree:</p>
<p>::: center
<img alt="image" height="3cm" src="../Figure/7/relation.png" />
:::</p>
<p>There's two types of procedures called [Left-Rotate]{.smallcaps} and
[Right-Rotate]{.smallcaps}.</p>
<p>::: center
<img alt="image" src="../Figure/7/rbt_rot1.png" width="80%" />
:::</p>
<p>The letters <span class="arithmatex">\(\alpha\)</span>, <span class="arithmatex">\(\beta\)</span>, and
<span class="arithmatex">\(\gamma\)</span> represent an arbitrary sub-treeall of them have
the same black-height. First, determine if recoloring needs to be done.</p>
<dl>
<dt>Case One:</dt>
<dd>
<p>If [<code>x</code>]{style="background-color: light-gray"}'s uncle,
[<code>y</code>]{style="background-color: light-gray"}, is red. Proceed with
recoloring.</p>
</dd>
</dl>
<p>Push <span class="arithmatex">\(C\)</span>'s black onto <span class="arithmatex">\(A\)</span> and
<span class="arithmatex">\(D\)</span>. Recurse and check for <span class="arithmatex">\(C\)</span>'s uncle if it
exists.</p>
<p>::: center
<img alt="image" height="4cm" src="../Figure/7/rbt_case1.png" />
:::</p>
<dl>
<dt>Case Two:</dt>
<dd>
<p>If [<code>x</code>]{style="background-color: light-gray"}'s uncle,
[<code>y</code>]{style="background-color: light-gray"}, is black and there's a
LR or RL imbalance.</p>
</dd>
</dl>
<p>::: center
<img alt="image" height="4cm" src="../Figure/7/rbt_case2.png" />
:::</p>
<p>There are four restructuring configurations depending on whether the
double red nodes (<span class="arithmatex">\(A\)</span> and <span class="arithmatex">\(B\)</span>) are left or
right children.</p>
<p>::: center
<img alt="image" src="../Figure/7/rbt_rot2.png" width="\textwidth" />
:::</p>
<p>If there's a LR imbalance, perform [Left-Rotate]{.smallcaps} on middle
node. Proceed to Case Three.</p>
<p>::: center
<img alt="image" src="../Figure/7/rbt_rot3.1.png" width="70%" />
:::</p>
<p>If there's a RL imbalance, perform [Right-Rotate]{.smallcaps} on middle
node. Proceed to Case Three.</p>
<p>::: center
<img alt="image" src="../Figure/7/rbt_rot3.2.png" width="70%" />
:::</p>
<dl>
<dt>Case Three:</dt>
<dd>
<p>If [<code>x</code>]{style="background-color: light-gray"}'s uncle,
[<code>y</code>]{style="background-color: light-gray"}, is black and there's a
LL or RR imbalance. Preserve the color</p>
</dd>
</dl>
<p>If there's a LL imbalance, perform [Right-Rotate]{.smallcaps} on top
node.</p>
<p>::: center
<img alt="image" src="../Figure/7/rbt_rot4.1.png" width="70%" />
:::</p>
<p>If there's a RR imbalance, perform [Left-Rotate]{.smallcaps} on top
node.</p>
<p>::: center
<img alt="image" src="../Figure/7/rbt_rot4.2.png" width="70%" />
:::</p>
<p>-3ex -0.1ex -.4ex 0.5ex .2ex Insertion and Deletion To perform
insertion, we insert [<code>x</code>]{style="background-color: light-gray"} and
color it red. The motivation for using the color red is that only
property 2 and 3 might be brokenthese violation are fairly easy to fix.</p>
<p>The [RB-Insert]{.smallcaps} procedure performs the following three cases
describe in the previous section. The running time is
<span class="arithmatex">\(\text{O}(\log{n})\)</span>.</p>
<p>Suppose we want to insert <span class="arithmatex">\(15\)</span> using the red-black tree
shown in the beginning, then we would insert as we normally would in a
BST and color it red. Refer to the diagram below:</p>
<p>::: center
<img alt="image" src="../Figure/7/rbt_insert.png" width="\textwidth" />
:::</p>
<p>Just like deleting a node in a BST, it's just as complicated to delete a
node in a red-black tree. The process for deleting node can be broken
into three cases:</p>
<dl>
<dt>Case One:</dt>
<dd>
<p>If the deleted node is red, perform the deletion as you would in
BST. No color changes should occur.</p>
</dd>
</dl>
<p>::: center
<img alt="image" src="../Figure/7/rbt_deletion1.1.png" width="90%" />
<img alt="image" src="../Figure/7/rbt_deletion1.2.png" width="90%" />
<img alt="image" src="../Figure/7/rbt_deletion1.3.png" width="90%" />
:::</p>
<dl>
<dt>Case Two:</dt>
<dd>
<p>If the deleted node is black and has one red child. Reattach the red
child in place of the black node we removed, then recolor the red
node as black to fix black-height of the tree.</p>
</dd>
</dl>
<p>::: center
<img alt="image" src="../Figure/7/rbt_deletion2.png" width="90%" />
:::</p>
<dl>
<dt>Case Three:</dt>
<dd>
<p>If the deleted node is black. Reattach a black child in place of the
black node we removed, then recolor as a double black.</p>
</dd>
</dl>
<p>::: center
<img alt="image" src="../Figure/7/rbt_deletion3.png" width="90%" />
:::</p>
<p>The double black is to keep track of where we violated the black depth
property. Denoted as [<code>r</code>]{style="background-color: light-gray"} and the
sibling of [<code>r</code>]{style="background-color: light-gray"} as
[<code>y</code>]{style="background-color: light-gray"}, we'll divide this into
three sub-cases based on [<code>y</code>]{style="background-color: light-gray"}:</p>
<p>::: list</p>
<p>The color of [<code>x</code>]{style="background-color: light-gray"}, parent of
[<code>z</code>]{style="background-color: light-gray"}, displayed can be black or
red. These three sub-cases differ only on the color of
[<code>y</code>]{style="background-color: light-gray"}, sibling of
[<code>r</code>]{style="background-color: light-gray"}.
:::</p>
<dl>
<dt>Case Three (a):</dt>
<dd>
<p>The sibling [<code>y</code>]{style="background-color: light-gray"} of
[<code>r</code>]{style="background-color: light-gray"} is black and has a red
child [<code>z</code>]{style="background-color: light-gray"}.</p>
</dd>
</dl>
<p>::: center
<img alt="image" src="../Figure/7/rbt_deletion3a.png" width="60%" />
:::</p>
<p>If [<code>z</code>]{style="background-color: light-gray"} is a left child, perform
[Right-Rotate]{.smallcaps} on
[<code>y</code>]{style="background-color: light-gray"}, then proceed below.</p>
<p>::: center
<img alt="image" src="../Figure/7/rbt_deletion3_1a.png" width="90%" />
:::</p>
<blockquote>
<p>If [<code>z</code>]{style="background-color: light-gray"} is a right child,
perform [Right-Rotate]{.smallcaps} on
[<code>x</code>]{style="background-color: light-gray"}. We color
[<code>x</code>]{style="background-color: light-gray"} and
[<code>z</code>]{style="background-color: light-gray"} black, give
[<code>y</code>]{style="background-color: light-gray"} the former color of
[<code>x</code>]{style="background-color: light-gray"}, and color
[<code>r</code>]{style="background-color: light-gray"} black.</p>
</blockquote>
<p>::: center
<img alt="image" src="../Figure/7/rbt_deletion3_1b.png" width="90%" />
:::</p>
<p>As you can see, we managed to achieve the same configuration as the
original tree prior to the deletion of node. We basically converted the
red node to be a black node, thus maintaining the red-black tree
property.</p>
<dl>
<dt>Case Three (b):</dt>
<dd>
<p>The sibling [<code>y</code>]{style="background-color: light-gray"} of
[<code>r</code>]{style="background-color: light-gray"} is black and both
children of [<code>y</code>]{style="background-color: light-gray"} are black.</p>
</dd>
</dl>
<p>::: center
<img alt="image" src="../Figure/7/rbt_deletion3b.png" width="60%" />
:::</p>
<p>If [<code>x</code>]{style="background-color: light-gray"} is red, we color it
black, then we color [<code>r</code>]{style="background-color: light-gray"} black
and [<code>y</code>]{style="background-color: light-gray"} red.</p>
<p>::: center
<img alt="image" src="../Figure/7/rbt_deletion3_2b.png" width="90%" />
:::</p>
<p>Otherwise, we only color [<code>r</code>]{style="background-color: light-gray"}
black and [<code>y</code>]{style="background-color: light-gray"} red.</p>
<p>::: center
<img alt="image" src="../Figure/7/rbt_deletion3_2a.png" width="90%" />
:::</p>
<p>In this case, we are essentially removing one black-height from the
other sub-tree, to deal with the double black.</p>
<dl>
<dt>Case Three (c):</dt>
<dd>
<p>The sibling [<code>y</code>]{style="background-color: light-gray"} of
[<code>r</code>]{style="background-color: light-gray"} is red. Perform an
adjustment operation.</p>
</dd>
</dl>
<p>::: center
<img alt="image" src="../Figure/7/rbt_deletion3c.png" width="60%" />
:::</p>
<blockquote>
<p>If [<code>y</code>]{style="background-color: light-gray"} is the right child of
[<code>x</code>]{style="background-color: light-gray"}, perform
[Left-Rotate]{.smallcaps} on
[<code>x</code>]{style="background-color: light-gray"}. We color
[<code>y</code>]{style="background-color: light-gray"} black and
[<code>x</code>]{style="background-color: light-gray"} red.</p>
</blockquote>
<p>::: center
<img alt="image" src="../Figure/7/rbt_deletion3_3a.png" width="90%" />
:::</p>
<blockquote>
<p>If [<code>y</code>]{style="background-color: light-gray"} is the left child of
[<code>x</code>]{style="background-color: light-gray"}, perform
[Right-Rotate]{.smallcaps} on
[<code>x</code>]{style="background-color: light-gray"}. We color
[<code>y</code>]{style="background-color: light-gray"} black and
[<code>x</code>]{style="background-color: light-gray"} red.</p>
</blockquote>
<p>::: center
<img alt="image" src="../Figure/7/rbt_deletion3_3b.png" width="90%" />
:::</p>
<p>The sibling of [<code>r</code>]{style="background-color: light-gray"} should be
black now, thus solve using Case Three (a) or Case Three (b).</p>
<p>::: list</p>
<p>In Case Three (a) and Case Three (b), if
[<code>r</code>]{style="background-color: light-gray"} is in the right-side instead
of the left-side, the direction of rotation changese.g.
[Right-Rotate]{.smallcaps} instead of [Left-Rotate]{.smallcaps} and
vice-versa, as we have done in Case Three (c).
:::</p>
<p>-3ex -0.1ex -.4ex 0.5ex .2ex Comparing AVL and Red-Black Trees Since
both provide dynamic-set operations in <span class="arithmatex">\(\text{O}(\log{n})\)</span>
time, which one to choose?</p>
<ul>
<li>
<p>AVL trees provide faster lookups than Red Black Trees because they
    are more strictly balanced.</p>
</li>
<li>
<p>Red-Black Trees provide faster insertion and removal operations than
    AVL trees as fewer rotations are done due to relatively relaxed
    balancing.</p>
</li>
<li>
<p>AVL trees store balance factors or heights with each node, thus
    requires storage for an integer per node whereas Red Black Tree
    requires only 1 bit of information per node.</p>
</li>
<li>
<p>Red-Black Trees are used in most of the language libraries like map,
    multi-map, multi-set in C++ whereas AVL trees are used in databases
    where faster retrievals are required.</p>
</li>
</ul>
<h1 id="graph">Graph<a class="headerlink" href="#graph" title="Permanent link">&para;</a></h1>
<p>-4ex -1ex -.4ex 1ex .2ex Properties of a Graph A graph should consists
of the following:</p>
<ol>
<li>
<p>Vertices (nodes), which specify some entities we are interested in.</p>
</li>
<li>
<p>Edges (lines), which specify the relationship between entities.</p>
</li>
<li>
<p>Weights (number in lines), which specify the weight the edge
    represent.</p>
</li>
</ol>
<p>The formal definition of a graph is a pair <span class="arithmatex">\((V,E)\)</span> where:</p>
<ul>
<li>
<p><span class="arithmatex">\(V\)</span> is a collection of nodes, called vertices.</p>
</li>
<li>
<p><span class="arithmatex">\(E\)</span> is a collection of pairs of vertices, called edges.</p>
</li>
</ul>
<p>::: exampleT
<strong>Example 8.1</strong>. <em>We can represent the following graph using the given
vertices and edges:</em></p>
<ul>
<li>
<p><em><span class="arithmatex">\(V = \{a,b,c,d,e,f\}\)</span></em></p>
</li>
<li>
<p><em><span class="arithmatex">\(E = \{(a,c),(b,c),(c,f),(b,d),(d,f),(c,d)\}\)</span></em></p>
</li>
</ul>
<p>::: center
<img alt="image" height="3cm" src="../Figure/8/graph.png" />
:::
:::</p>
<p>A graph can be categorized into one of two types, depending on the edge
type:</p>
<dl>
<dt>Undirected Graph.</dt>
<dd>
<p>Edges do not have a directionundirected edge are unordered pair of
vertices, such that <span class="arithmatex">\((u,v)\)</span> and <span class="arithmatex">\((v,u)\)</span>
are the same edge.</p>
<p>::: center
<img alt="image" height="0.75cm" src="../Figure/8/edge1.png" />
:::</p>
</dd>
<dt>Directed Graph.</dt>
<dd>
<p>Edges with directiondirected edges are ordered pair of vertices,
such that <span class="arithmatex">\(\langle u,v \rangle\)</span> and
<span class="arithmatex">\(\langle v,u \rangle\)</span> are two different edges.</p>
<p>::: center
<img alt="image" height="0.75cm" src="../Figure/8/edge2.png" />
<img alt="image" height="0.75cm" src="../Figure/8/edge3.png" />
:::</p>
</dd>
</dl>
<p>To distinguish between the two edge types, we use round brackets
<span class="arithmatex">\(( )\)</span> for unordered pairs and angle brackets
<span class="arithmatex">\(\langle \rangle\)</span> for ordered pairs.</p>
<p>-3ex -0.1ex -.4ex 0.5ex .2ex Graph Terminology We will go over a few
graph terminologies, some of which you should be familiar with.</p>
<ul>
<li>
<p>The degree of a vertex is the number of incident edges of this
    vertex. Below are some examples. Pay close attention to the degree
    of vertex <span class="arithmatex">\(z\)</span>.</p>
<p>::: center
<img alt="image" height="3cm" src="../Figure/8/Terminology/graph_deg.png" />
:::</p>
<p>Let <span class="arithmatex">\(m\)</span> be the number of edges and
<span class="arithmatex">\(\deg(a)\)</span> be the degree of vertex <span class="arithmatex">\(a\)</span>,
then <span class="arithmatex">\(<span class="arithmatex">\(\sum_{a \in V}\deg(a) = 2m\)</span>\)</span></p>
</li>
<li>
<p>For undirected graphs, parallel edges are edges that have the same
    endpoints, whereas for directed graph, they are edges that have the
    same origin and destination.</p>
<p>::: center
<img alt="image" height="3cm" src="../Figure/8/Terminology/graph_parallel.png" />
:::</p>
</li>
<li>
<p>Self-loop is an edge whose endpoints coincide, such as the edge
    <span class="arithmatex">\((z,z)\)</span></p>
<p>::: center
<img alt="image" height="3cm" src="../Figure/8/Terminology/graph_sloop.png" />
:::</p>
</li>
</ul>
<p>In this course, we will deal almost exclusively with simple graphs,
which are graphs that do not have a parallel edge or self-loop. Let
<span class="arithmatex">\(n\)</span> be the number of vertices and <span class="arithmatex">\(m\)</span> the
number of edges, then <span class="arithmatex">\(<span class="arithmatex">\(m \leq \frac{n(n - 1)}{2}\)</span>\)</span></p>
<p>There are various definitions used to describe the movement in a graph:</p>
<ul>
<li>
<p>A path is a sequence of vertices, such that consecutive vertices are
    adjacent.</p>
<ul>
<li>A simple path is path such that all its vertices are distinct.</li>
</ul>
<p>::: center
<img alt="image" height="3cm" src="../Figure/8/Terminology/graph_path.png" />
:::</p>
</li>
<li>
<p>A cycle is a path on which the first vertex is equal to the last
    vertex.</p>
<ul>
<li>A simple cycle is a cycle such that all its vertices are
    distinct, except the first and last one.</li>
</ul>
<p>::: center
<img alt="image" height="3cm" src="../Figure/8/Terminology/graph_cycle.png" />
:::</p>
</li>
</ul>
<p>Lastly, we'll cover the characteristics of a connected graph and the
definition of a subgraph.</p>
<ul>
<li>
<p>A connected graph is a graph in which there is a path from any
    vertex to any other vertex in the graph.</p>
<p>::: center
<img alt="image" height="3cm" src="../Figure/8/Terminology/graph_connected.png" />
:::</p>
</li>
<li>
<p>We can say a tree is a connected graph without a cycleany two
    vertices are connected by exactly one path.</p>
<p>::: center
<img alt="image" height="2cm" src="../Figure/8/Terminology/graph_tree.png" />
:::</p>
</li>
<li>
<p>A subgraph of a graph <span class="arithmatex">\((V,E)\)</span> is a pair
    <span class="arithmatex">\((V', E')\)</span> where <span class="arithmatex">\(V' \subseteq V\)</span> and
    <span class="arithmatex">\(E' \subseteq E\)</span>. Both endpoints of edges in
    <span class="arithmatex">\(E'\)</span> are in <span class="arithmatex">\(V'\)</span>.</p>
<p>::: center
<img alt="image" height="5cm" src="../Figure/8/Terminology/graph_sub.png" />
:::</p>
</li>
<li>
<p>Then a spanning tree is a subgraph of a connected graph, which
    includes all vertices of the connected graph.</p>
<p>::: center
<img alt="image" height="5cm" src="../Figure/8/Terminology/graph_span.png" />
:::</p>
</li>
</ul>
<p>-4ex -1ex -.4ex 1ex .2ex Representations of Graphs We can choose between
two standard ways to represent a graph <span class="arithmatex">\(G = (V,E)\)</span>, as a
collection of:</p>
<ol>
<li>
<p>Adjacency list</p>
</li>
<li>
<p>Adjacency matrix</p>
</li>
</ol>
<p>Either way applies to both directed and undirected graph. They are
useful in representing dense and sparse graphs:</p>
<dl>
<dt>Sparse graphs.</dt>
<dd>
<p>A graph with only a few edge.</p>
</dd>
<dt>Dense graphs.</dt>
<dd>
<p>The number of edges is close to the maximal number of edges.</p>
</dd>
</dl>
<p>::: center
<img alt="image" height="2.5cm" src="../Figure/8/dense_sparse.png" />
:::</p>
<p>-3ex -0.1ex -.4ex 0.5ex .2ex Adjacency List The adjacency-list
representation of a graph consists of an array
<span class="arithmatex">\(\textit{Adj}\)</span> of <span class="arithmatex">\(|V|\)</span> list, one for each
vertex in <span class="arithmatex">\(V\)</span>.</p>
<ul>
<li>
<p>For an undirected graph, the adjacency list
    <span class="arithmatex">\(\textit{Adj}[u]\)</span> contains all the vertices
    <span class="arithmatex">\(v\)</span> such that there is an edge
    <span class="arithmatex">\((u,v), (v,u) \in E\)</span>.</p>
<p>::: center
<img alt="image" height="3cm" src="../Figure/8/Adjacency/adjacency_list1.png" />
:::</p>
<p>Alternatively, you can think of it as a list of all the vertices
adjacent to <span class="arithmatex">\(u\)</span>.</p>
<p>::: center
<img alt="image" height="2.5cm" src="../Figure/8/Adjacency/adjacency_list1a.png" />
:::</p>
</li>
</ul>
<p><div class="highlight"><pre><span></span><code><span class="linenos" data-linenos="1 "></span>&lt;!-- --&gt;
</code></pre></div>
-   For a directed graph, the adjacency list
    <span class="arithmatex">\(\textit{Adj}[u]\)</span> contains all the vertices
    <span class="arithmatex">\(v\)</span> such that there is an edge
    <span class="arithmatex">\(\langle u,v \rangle \in E\)</span>.</p>
<div class="highlight"><pre><span></span><code><span class="linenos" data-linenos=" 1 "></span>::: center
<span class="linenos" data-linenos=" 2 "></span>![image](Figure/8/Adjacency/adjacency_list2.png){height=&quot;3cm&quot;}
<span class="linenos" data-linenos=" 3 "></span>:::
<span class="linenos" data-linenos=" 4 "></span>
<span class="linenos" data-linenos=" 5 "></span>Alternatively, you can think of it as a list of destinations given
<span class="linenos" data-linenos=" 6 "></span>the origin $u$.
<span class="linenos" data-linenos=" 7 "></span>
<span class="linenos" data-linenos=" 8 "></span>::: center
<span class="linenos" data-linenos=" 9 "></span>![image](Figure/8/Adjacency/adjacency_list2a.png){height=&quot;2.5cm&quot;}
<span class="linenos" data-linenos="10 "></span>:::
</code></pre></div>
<p>::: list</p>
<p>Note that in an adjacency list, the order doesn't matter, meaning we
could have listed the vertex in any order.
:::</p>
<p>A useful thing we could do with adjacency list is to represent weighted
graphsedges with an associated weight to them. It can easily be done by
storing it with vertex <span class="arithmatex">\(v\)</span> in <span class="arithmatex">\(u\)</span>'s adjacency
list.</p>
<p>::: center
<img alt="image" height="3cm" src="../Figure/8/Adjacency/graph_weight1.png" />
:::</p>
<p>A potential disadvantage of the adjacency-list representation is that
there is no quicker way to determine if a given edge
<span class="arithmatex">\((u,v)\)</span> is present in the graph.</p>
<ol>
<li>
<p>We would need to search for <span class="arithmatex">\(v\)</span> in the adjacency list
    <span class="arithmatex">\(\textit{Adj}[u]\)</span>.</p>
</li>
<li>
<p>If we want to check the edge <span class="arithmatex">\((2,4)\)</span>, then we would
    need search through <span class="arithmatex">\(\textit{Adj}[2]\)</span>.</p>
<p>::: center
<img alt="image" height="2.5cm" src="../Figure/8/Adjacency/list_search.png" />
:::</p>
</li>
<li>
<p>The worst-case running time would be the number of adjacent
    vertices, which is not ideal.</p>
</li>
</ol>
<p>A solution would be to use an adjacency-matrix representation, which
requires a constant time <span class="arithmatex">\(\text{O}(1)\)</span>, but at the cost of
using asymptotically more memory.</p>
<p>-3ex -0.1ex -.4ex 0.5ex .2ex Adjacency Matrix The adjacency-matrix
representation of a graph consists of a <span class="arithmatex">\(|V| \times |V|\)</span>
matrixassuming the vertices are numbered from <span class="arithmatex">\(1\)</span>,
<span class="arithmatex">\(2\)</span>, ..., to <span class="arithmatex">\(|V|\)</span>.</p>
<p>We can represent the elements inside the matrix <span class="arithmatex">\(A\)</span> as
<span class="arithmatex">\(a_{ij}\)</span>, where <span class="arithmatex">\(i\)</span> and <span class="arithmatex">\(j\)</span>
indicate the row and column.</p>
<ul>
<li>
<p>For an undirected graph, if there is an edge
    <span class="arithmatex">\((i,j), (j,i) \in E\)</span>, then set
    <span class="arithmatex">\(a_{ij} = 1\)</span>, otherwise, <span class="arithmatex">\(a_{ij} = 0\)</span>.</p>
<p>::: center
<img alt="image" height="3cm" src="../Figure/8/Adjacency/adjacency_mat1.png" />
:::</p>
<p>Notice how <span class="arithmatex">\(a_{22}\)</span> is <span class="arithmatex">\(0\)</span>, since the edge
<span class="arithmatex">\((2,2)\)</span> does not exist.</p>
<p>::: center
<img alt="image" height="2.5cm" src="../Figure/8/Adjacency/adjacency_mat1a.png" />
:::</p>
</li>
<li>
<p>For a directed graph, if there is an edge
    <span class="arithmatex">\(\langle i, j \rangle \in E\)</span>, then set
    <span class="arithmatex">\(a_{ij} = 1\)</span>, otherwise, <span class="arithmatex">\(a_{ij} = 0\)</span>.</p>
<p>::: center
<img alt="image" height="3cm" src="../Figure/8/Adjacency/adjacency_mat2.png" />
:::</p>
</li>
</ul>
<p>Like the adjacency-list representation of a graph, an adjacency matrix
can represent a weighted graph. Instead of storing <span class="arithmatex">\(0\)</span>'s
and <span class="arithmatex">\(1\)</span>'s, we store the weight of the given edge.</p>
<p>::: center
<img alt="image" height="3cm" src="../Figure/8/Adjacency/graph_weight2.png" />
:::</p>
<p>If an edge does not exist, we can store a [nil]{.smallcaps} value,
depicted as empty in the diagram above.</p>
<p>-3ex -0.1ex -.4ex 0.5ex .2ex Comparison As we have demonstrated both are
applicable to undirected and directed graphs, each with their own
advantages and disadvantages.</p>
<div class="highlight"><pre><span></span><code><span class="linenos" data-linenos="1 "></span>                                                                **Adjacency List**             **Adjacency Matrix**
</code></pre></div>
<hr />
<div class="highlight"><pre><span></span><code><span class="linenos" data-linenos="1 "></span>                      **Space:**                          $\Theta(|V + E|)$   $\Theta(|V|^2)$
</code></pre></div>
<p><strong>Time:</strong> List all vertices adjacent to <span class="arithmatex">\(u\)</span>   <span class="arithmatex">\(\Theta(\deg(u))\)</span>    <span class="arithmatex">\(\Theta(|V|)\)</span>
      <strong>Time:</strong> Determine if <span class="arithmatex">\((u,v) \in E\)</span>       <span class="arithmatex">\(\Theta(\deg(u))\)</span>     <span class="arithmatex">\(\Theta(1)\)</span></p>
<p>The choice of which one to use comes down to the following criteria:</p>
<ul>
<li>
<p>The adjacency-list representation provides a compact way to
    represent sparse graphsthose for which <span class="arithmatex">\(|E|\)</span> is much
    less than <span class="arithmatex">\(|V|^2\)</span>.</p>
</li>
<li>
<p>However, if <span class="arithmatex">\(|E|\)</span> is close to <span class="arithmatex">\(|V|^2\)</span>,
    then we may choose an adjacency-matrix representation since it
    almost have the same space complexity as the adjacency-list.</p>
</li>
<li>
<p>Alternatively, if we need to be able to tell quickly if there is an
    edge connecting two given vertices, an adjacency-matrix
    representation is used.</p>
</li>
</ul>
<p>-4ex -1ex -.4ex 1ex .2ex Graph Traversals A traversal (or graph
searching) is a systematic procedure for exploring a connected graph by
examining all its vertices and/or edges. There's two types of traversal
algorithms:</p>
<ol>
<li>
<p>Breadth-First Search (BFS)</p>
</li>
<li>
<p>Depth-First Search (DFS)</p>
</li>
</ol>
<p>-3ex -0.1ex -.4ex 0.5ex .2ex Breadth-First Search Breadth-first search
(BFS) is one of the simplest algorithms for searching a graph, which
uses a queue data structure.</p>
<p>For simplicity, we will use a tree to describe breadth-first search:</p>
<ol>
<li>
<p>Let's start at the root of tree. Let's add <span class="arithmatex">\(A\)</span> to the
    queue.</p>
<p>::: center
<img alt="image" height="3cm" src="../Figure/8/BFS/tree1.png" />
:::</p>
</li>
<li>
<p>We want to explore all the vertices that are adjacent to
    <span class="arithmatex">\(A\)</span>, which are <span class="arithmatex">\(B\)</span> and <span class="arithmatex">\(C\)</span>.
    We will add them to the queue.</p>
<p>::: center
<img alt="image" height="3cm" src="../Figure/8/BFS/tree2.png" />
:::</p>
<p>Note that the order they are placed in queue does not matter. We
could have stored <span class="arithmatex">\(C\)</span> first.</p>
</li>
<li>
<p>Since we finished \"exploring\" <span class="arithmatex">\(A\)</span>, we will move on,
    then <span class="arithmatex">\(B\)</span> is next in queue.</p>
<p>::: center
<img alt="image" height="3cm" src="../Figure/8/BFS/tree3.png" />
:::</p>
</li>
<li>
<p>Likewise, we add all vertices adjacent to <span class="arithmatex">\(B\)</span>, which
    are <span class="arithmatex">\(D\)</span> and <span class="arithmatex">\(E\)</span>, to the queue.</p>
<p>::: center
<img alt="image" height="3cm" src="../Figure/8/BFS/tree4.png" />
:::</p>
</li>
<li>
<p>Since we finished \"exploring\" <span class="arithmatex">\(B\)</span> , we will move to
    <span class="arithmatex">\(C\)</span>.</p>
<p>::: center
<img alt="image" height="3cm" src="../Figure/8/BFS/tree5.png" />
:::</p>
</li>
<li>
<p>We will add the vertices adjacent to <span class="arithmatex">\(C\)</span>. which are
    <span class="arithmatex">\(F\)</span> and <span class="arithmatex">\(G\)</span> to the queue.</p>
<p>::: center
<img alt="image" height="3cm" src="../Figure/8/BFS/tree6.png" />
:::</p>
</li>
<li>
<p>When we move to vertex <span class="arithmatex">\(D\)</span>, you will see there are no
    adjacent vertices, thus we don't add anything to the queue and move
    on to <span class="arithmatex">\(E\)</span>.</p>
<p>::: center
<img alt="image" height="3cm" src="../Figure/8/BFS/tree7.png" />
:::</p>
</li>
<li>
<p>The same can be said for <span class="arithmatex">\(E\)</span> through <span class="arithmatex">\(G\)</span>,
    in which we finish our breadth-first search.</p>
<p>::: center
<img alt="image" height="3cm" src="../Figure/8/BFS/tree8.png" />
:::</p>
</li>
</ol>
<p>This is a simplified explanation, but should provide a general idea of
how it works. We associate the vertex colors to guide the algorithm:</p>
<ul>
<li>
<p>White vertices have not been discovered. All vertices start out
    white.</p>
</li>
<li>
<p>Grey vertices are discovered but not fully explored.</p>
</li>
<li>
<p>Black vertices are discovered and fully explored.</p>
</li>
</ul>
<p>The algorithm attaches several attributes to each vertex, such as color
[<code>u.color</code>]{style="background-color: light-gray"}, parent
[<code>u.\pi</code>]{style="background-color: light-gray"}, and distance
[<code>u.d</code>]{style="background-color: light-gray"} which is computed by the
algorithm.</p>
<ul>
<li>
<p>To keep track of progress, breadth-first search colors each vertex
    white, grey, or black.</p>
</li>
<li>
<p>Distance is used to represent the smallest number of edges that must
    be traverse from the starting vertex
    [<code>s</code>]{style="background-color: light-gray"} to end vertex
    [<code>v</code>]{style="background-color: light-gray"}.</p>
</li>
</ul>
<p>::: algorithm
[BFS]{.smallcaps} <span class="arithmatex">\((G,s)\)</span></p>
<p>::: algorithmic
:::
:::</p>
<p>We start off by painting every vertex
[<code>white</code>]{style="background-color: light-gray"} except our starting
vertex [<code>s</code>]{style="background-color: light-gray"} and setting the
distance to [<code>\infty</code>]{style="background-color: light-gray"}, as we not
sure how far it is from the starting vertex or whether it is even
reachable.</p>
<p>::: algorithm
::: algorithmic
:::
:::</p>
<p>Then we paint our starting vertex
[<code>s</code>]{style="background-color: light-gray"} to
[<code>grey</code>]{style="background-color: light-gray"}, set the distance to
[<code>0</code>]{style="background-color: light-gray"}, since it's our starting
point. The parent of [<code>s</code>]{style="background-color: light-gray"} is
[<code>nil</code>]{style="background-color: light-gray"}doesn't exist.</p>
<p>::: center
<img alt="image" height="2cm" src="../Figure/8/BFS/operation1.png" />
:::</p>
<p>Note that vertex [<code>s</code>]{style="background-color: light-gray"} is
something that we chose, which in this example is
[<code>5</code>]{style="background-color: light-gray"}.</p>
<p>::: algorithm
::: algorithmic
:::
:::</p>
<p>Then we initialize [<code>Q</code>]{style="background-color: light-gray"} to the
queue containing just the vertex
[<code>s</code>]{style="background-color: light-gray"} which is
[<code>5</code>]{style="background-color: light-gray"}.</p>
<p>::: center
<img alt="image" height="2cm" src="../Figure/8/BFS/operation2.png" />
:::</p>
<p>::: algorithm
::: algorithmic
:::
:::</p>
<p>The [<code>while</code>]{style="background-color: light-gray"} loop functions
similarly to what we have demonstrated in the first example.</p>
<p>::: center
<img alt="image" src="../Figure/8/BFS/operation3.png" width="\textwidth" />
<img alt="image" src="../Figure/8/BFS/operation4.png" width="\textwidth" />
<img alt="image" src="../Figure/8/BFS/operation5.png" width="\textwidth" />
<img alt="image" src="../Figure/8/BFS/operation6.png" width="\textwidth" />
:::</p>
<p>The total running time of the [BFS]{.smallcaps} procedure is
<span class="arithmatex">\(\text{O}(V + E)\)</span>. As you may have notice, it is
particularly useful for finding the shortest path from the starting
vertex [<code>s</code>]{style="background-color: light-gray"} to some vertex
[<code>v</code>]{style="background-color: light-gray"} in the graph.</p>
<p>-3ex -0.1ex -.4ex 0.5ex .2ex Depth-First Search Depth-first search (DFS)
as the name implies, searches \"deeper\" first until it cannot go
further at which point it backtracks and continues, which uses a stack
data structure.</p>
<p>Let's use the same tree as we have used for BFS, to compare the
difference:</p>
<ol>
<li>
<p>As before, we will start at the root of three. Let's add
    <span class="arithmatex">\(A\)</span> to the stack.</p>
<p>::: center
<img alt="image" height="3cm" src="../Figure/8/DFS/tree1.png" />
:::</p>
</li>
<li>
<p>Then we arbitrarily pick an edge outwards of <span class="arithmatex">\(A\)</span>, which
    will choose <span class="arithmatex">\(B\)</span> and add to the stack.</p>
<p>::: center
<img alt="image" height="3cm" src="../Figure/8/DFS/tree2.png" />
:::</p>
<p>Note there's multiple ways, so we could have also chosen to go with
vertex <span class="arithmatex">\(C\)</span> instead.</p>
</li>
<li>
<p>Continue to pick an edge outwards, which there is only one, so will
    choose <span class="arithmatex">\(D\)</span>.</p>
<p>::: center
<img alt="image" height="3cm" src="../Figure/8/DFS/tree3.png" />
:::</p>
</li>
<li>
<p>Since there's no more vertices to explore, we backtrack to vertex
    <span class="arithmatex">\(B\)</span>.</p>
<p>::: center
<img alt="image" height="3cm" src="../Figure/8/DFS/tree4.png" />
:::</p>
</li>
<li>
<p>Continue to pick an edge outwards that has not been visited yet,
    which is vertex <span class="arithmatex">\(E\)</span>.</p>
<p>::: center
<img alt="image" height="3cm" src="../Figure/8/DFS/tree5.png" />
:::</p>
</li>
<li>
<p>Then we backtrack all the way to vertex <span class="arithmatex">\(A\)</span>, since all
    of vertex <span class="arithmatex">\(B\)</span> and <span class="arithmatex">\(E\)</span> has been explored.</p>
<p>::: center
<img alt="image" height="3cm" src="../Figure/8/DFS/tree6.png" />
:::</p>
</li>
<li>
<p>Then, we repeat the same steps for the right sub-tree, by picking
    some arbitrary edge outwards until we have fully discovered every
    vertex.</p>
</li>
</ol>
<p>DFS uses the same color scheme as we previously described in BFS.
However, one unique thing about the algorithm is the it uses two
timestamps for:</p>
<ul>
<li>
<p>when it first discovers the vertex
    [<code>u.d</code>]{style="background-color: light-gray"} and ...</p>
</li>
<li>
<p>when it finishes exploring the vertex
    [<code>u.f</code>]{style="background-color: light-gray"}.</p>
</li>
</ul>
<p>This is similar to BFS, which we paint every vertex
[<code>white</code>]{style="background-color: light-gray"}. The
[<code>time</code>]{style="background-color: light-gray"} is set to
[<code>0</code>]{style="background-color: light-gray"}, which will use to compute
the discovery time [<code>u.d</code>]{style="background-color: light-gray"} and
finishing time [<code>u.f</code>]{style="background-color: light-gray"}.</p>
<p>::: algorithm
[DFS]{.smallcaps} <span class="arithmatex">\((G)\)</span></p>
<p>::: algorithmic
:::
:::</p>
<p>For this example, we'll use a directed graph as it's \"easier\" to pick
an edge outwards and demonstrate.</p>
<p>::: center
<img alt="image" height="2.5cm" src="../Figure/8/DFS/operation1.png" />
:::</p>
<p>For demonstration purposes, the discovery time and finishing time is
denoted below the vertex, shown on the right.</p>
<p>::: algorithm
[DFS-Visit]{.smallcaps} <span class="arithmatex">\((G,u)\)</span></p>
<p>::: algorithmic
:::
:::</p>
<p>We'll choose vertex [<code>8</code>]{style="background-color: light-gray"} as our
starting vertex. It'll recursively call
[<code>DFS-Visit</code>]{style="background-color: light-gray"} until it reaches a
dead end then it colors the vertex black.</p>
<p>::: center
<img alt="image" src="../Figure/8/DFS/operation2.png" width="\textwidth" />
:::</p>
<p>Once the recursion finishes, it goes to the next
[<code>v</code>]{style="background-color: light-gray"} that is in
[<code>Adj[u]</code>]{style="background-color: light-gray"} and repeats the same
thing.</p>
<p>::: center
<img alt="image" src="../Figure/8/DFS/operation3.png" width="\textwidth" />
<img alt="image" src="../Figure/8/DFS/operation4.png" width="\textwidth" />
:::</p>
<p>Since there's no more [<code>v</code>]{style="background-color: light-gray"} (or
vertex to explore) in [<code>Adj[u]</code>]{style="background-color: light-gray"}.
We pick a new [<code>u</code>]{style="background-color: light-gray"}.</p>
<p>::: center
<img alt="image" src="../Figure/8/DFS/operation5.png" width="\textwidth" />
:::</p>
<p>The total running time of the [DFS]{.smallcaps} procedure is
<span class="arithmatex">\(\text{O}(V + E)\)</span>, similar to [BFS]{.smallcaps} procedure.
It provides valuable information about the structure of a graph and is
more suitable for decision treelike a maze.</p>
<p>We can use depth-first search to perform a topological sort of a
directed acyclic graph (dag)a directed graph with no cycles.</p>
<p>::: center
<img alt="image" src="../Figure/8/dag1.png" width="\textwidth" />
:::</p>
<p>By performing topological sort, we can find the topological
orderingordering of its vertices along a horizontal line so that all
directed edges go from left to right.</p>
<p>::: center
<img alt="image" src="../Figure/8/dag2.png" width="\textwidth" />
:::</p>
<p>Note how the order they are listed in regarding their finishing times.
The [Topological-Sort]{.smallcaps} sorts a dag by:</p>
<p>::: algorithm
[Topological-Sort]{.smallcaps} <span class="arithmatex">\((G)\)</span></p>
<p>::: algorithmic
:::
:::</p>
<p>We can perform [Topological-Sort]{.smallcaps} in
<span class="arithmatex">\(\text{O}(V + E)\)</span> time, since DFS takes
<span class="arithmatex">\(\text{O}(V + E)\)</span>.</p>
<h1 id="elementary-graph-algorithms">Elementary Graph Algorithms<a class="headerlink" href="#elementary-graph-algorithms" title="Permanent link">&para;</a></h1>
<h2 id="minimum-spanning-tree">Minimum Spanning Tree<a class="headerlink" href="#minimum-spanning-tree" title="Permanent link">&para;</a></h2>
<p>The minimum spanning tree is the spanning tree of a weighted graph with minimum total edge weight. What this means, is suppose we have a connected graph with weighted edges.</p>
<p>::: center
<img alt="image" height="3cm" src="../Figure/8/MST/graph1.png" />
:::</p>
<p>We are interested in the subset of the edges which connects all vertices together, while minimizing the total edge cost. We can form three variations of the graph's spanning tree:</p>
<p>::: center
<img alt="image" height="3cm" src="../Figure/8/MST/graph2.png" />
:::</p>
<p>As you can see, tree 1 in particular is our minimum spanning tree because it posses the minimum total edge weight of <span class="arithmatex">\(71\)</span>. Obviously when there's more vertices and edges, it will be much harder to figure out the MST. And so we'll go over two types of algorithms which does the following:</p>
<ul>
<li>Kruskal's algorithm</li>
<li>Prim's algorithm</li>
</ul>
<p>For both algorithm, we will try and find the minimum spanning tree of the following completed graph below and compare them after.</p>
<p>::: center
<img alt="image" height="3cm" src="../Figure/8/MST/graph3.png" />
:::</p>
<h3 id="kruskals-algorithm">Kruskal's Algorithm<a class="headerlink" href="#kruskals-algorithm" title="Permanent link">&para;</a></h3>
<p>This algorithm creates a forest of trees. It works by picking the smallest edge then checking if it forms a cycle with the spanning tree formed so far. If not, the edge is added, otherwise, discard it.</p>
<ol>
<li>
<p>We start off by selecting the smallest edge in the graph, which is <span class="arithmatex">\((6,1)\)</span>, as it has an edge weight of <span class="arithmatex">\(10\)</span>.</p>
<p>::: center
<img alt="image" height="3cm" src="../Figure/8/MST/k1.png" />
:::</p>
</li>
<li>
<p>Then, we select the next smallest edge, which is <span class="arithmatex">\((4,3)\)</span>, with an edge weight of <span class="arithmatex">\(12\)</span>.</p>
<p>::: center
<img alt="image" height="3cm" src="../Figure/8/MST/k2.png" />
:::</p>
</li>
<li>
<p>The next minimum edge is <span class="arithmatex">\((7,2)\)</span>, with an edge weight of <span class="arithmatex">\(14\)</span>.</p>
<p>::: center
<img alt="image" height="3cm" src="../Figure/8/MST/k3.png" />
:::</p>
</li>
<li>
<p>The next minimum edge is <span class="arithmatex">\((2,3)\)</span>, with an edge weight of <span class="arithmatex">\(16\)</span>.</p>
<p>::: center
<img alt="image" height="3cm" src="../Figure/8/MST/k4.png" />
:::</p>
</li>
<li>
<p>The next minimum edge is <span class="arithmatex">\((7,4)\)</span>, with an edge weight of <span class="arithmatex">\(18\)</span>. However, notice that it forms a cycle, so we discard it.</p>
<p>::: center
<img alt="image" height="3cm" src="../Figure/8/MST/k5.png" />
:::</p>
<p>Instead, we go to the next minimum edge, <span class="arithmatex">\((5,4)\)</span>, with an edge weight of <span class="arithmatex">\(22\)</span>.</p>
<p>::: center
<img alt="image" height="3cm" src="../Figure/8/MST/k6.png" />
:::</p>
</li>
<li>
<p>The next minimum edge is <span class="arithmatex">\((5,6)\)</span>, with an edge weight of <span class="arithmatex">\(25\)</span>.</p>
<p>::: center
<img alt="image" height="3cm" src="../Figure/8/MST/k7.png" />
:::</p>
</li>
<li>
<p>Once we have all our vertices or have <span class="arithmatex">\(|V| - 1\)</span> edges, we are done with the algorithm. Our MST is complete, which has the weight of <span class="arithmatex">\(99\)</span>.</p>
</li>
</ol>
<h3 id="prims-algorithm">Prim's Algorithm<a class="headerlink" href="#prims-algorithm" title="Permanent link">&para;</a></h3>
<p>This algorithm starts with one node. It then adds a node one by one that is unconnected to the new graph. For this example, let's start at vertex <span class="arithmatex">\(6\)</span>.</p>
<ol>
<li>
<p>Since we started with <span class="arithmatex">\(6\)</span>, we have to select the smallest edge that is connected to <span class="arithmatex">\(6\)</span>, which are either: <span class="arithmatex">\(25\)</span> or <span class="arithmatex">\(10\)</span>.</p>
<p>::: center
<img alt="image" height="3cm" src="../Figure/8/MST/p1.png" />
:::</p>
<p>We'll select the edge weight of <span class="arithmatex">\(10\)</span>, since that's the smallest.</p>
</li>
<li>
<p>Likewise, we now have to select the smallest edge that is connected to either <span class="arithmatex">\(6\)</span> or <span class="arithmatex">\(1\)</span>, which will pick edge <span class="arithmatex">\((6,5)\)</span>, with an edge weight of <span class="arithmatex">\(25\)</span>.</p>
<p>::: center
<img alt="image" height="3cm" src="../Figure/8/MST/p2.png" />
:::</p>
</li>
<li>
<p>We are basically repeating the same step, but now with more and more edges to pick from. The dashed lines indicate the possible edges to select.</p>
<p>::: center
<img alt="image" height="3cm" src="../Figure/8/MST/p3.png" />
<img alt="image" height="3cm" src="../Figure/8/MST/p4.png" />
<img alt="image" height="3cm" src="../Figure/8/MST/p5.png" />
<img alt="image" height="3cm" src="../Figure/8/MST/p6.png" />
:::</p>
<p>While it was not demonstrated in this example, but if an edge is selected and it forms a cycle, we will discard it and choose the next minimum edge, similar to Kruskal's algorithm. </p>
</li>
<li>
<p>Once we have all our vertices or have <span class="arithmatex">\(|V| - 1\)</span> edges, we are done with the algorithm, which also have a weight of <span class="arithmatex">\(99\)</span>.</p>
</li>
</ol>
<p>As you can see, we have obtained the same MST for both Kruskal and Prim's algorithm, so which one to choose?</p>
<ul>
<li>Kruskal's algorithm runs faster in sparse graph, with the time complexity of <span class="arithmatex">\(\text{O}(E\log{V})\)</span>.</li>
<li>Prim's algorithm runs faster in dense graph, with the time complexity of <span class="arithmatex">\(\text{O}(E\log{V})\)</span>, but it can be improved up to <span class="arithmatex">\(\text{O}(E + V\log{V})\)</span> using Fibonacci heaps.</li>
</ul>
<h2 id="shortest-path">Shortest Path<a class="headerlink" href="#shortest-path" title="Permanent link">&para;</a></h2>
<p>We define the shortest path as the minimum length path from a vertex to another vertex in <span class="arithmatex">\(G\)</span>, if such a path exists. Previously, we have done something similar with breadth-first search with an unweighted graph, in which each edge has a weight of <span class="arithmatex">\(1\)</span>.</p>
<p>::: center
<img alt="image" height="3cm" src="../Figure/8/SP/bfs.png" />
:::</p>
<p>We are particularly interested in the single-source shortest path's problem, that is given a graph <span class="arithmatex">\(G = (V,E)\)</span>, what is the shortest path from a given source vertex <span class="arithmatex">\(s \in V\)</span> to each vertex <span class="arithmatex">\(v \in V\)</span>.</p>
<p>::: center
<img alt="image" height="3cm" src="../Figure/8/SP/ex_graph.png" />
:::</p>
<p>Suppose we chose <span class="arithmatex">\(A\)</span> as our source vertex, then the shortest-paths tree are: </p>
<p>::: center
<img alt="image" height="3cm" src="../Figure/8/SP/ex_sp.png" />
:::</p>
<p>If you calculate the weight from the source vertex <span class="arithmatex">\(A\)</span> to every other vertex, you will get the minimum edge weight possible. </p>
<ul>
<li>From <span class="arithmatex">\(A\)</span> to <span class="arithmatex">\(B\)</span>, the total edge weight is <span class="arithmatex">\(3\)</span>.</li>
<li>From <span class="arithmatex">\(A\)</span> to <span class="arithmatex">\(C\)</span>, the total edge weight is <span class="arithmatex">\(5\)</span>.</li>
<li>From <span class="arithmatex">\(A\)</span> to <span class="arithmatex">\(D\)</span>, the total edge weight is <span class="arithmatex">\(9\)</span>.</li>
<li>From <span class="arithmatex">\(A\)</span> to <span class="arithmatex">\(E\)</span>, the total edge weight is <span class="arithmatex">\(11\)</span>.</li>
</ul>
<p>You also may have notice that the shortest-paths tree are not unique, meaning there can also be more than one shortest-path tree, nonetheless should still provide the same answers. In  this section, we'll go over two algorithms which does the following:</p>
<ul>
<li>Dijkstra's algorithm </li>
<li>Bellman-Ford's algorithm</li>
</ul>
<p>As will demonstrate, each algorithm have their advantages and disadvantages when choosing one over the other. Both algorithm uses the [Relax]{.smallcaps} procedure, but implement them in varying ways.</p>
<p>::: algorithm
[Relax]{.smallcaps} <span class="arithmatex">\((u,v,w)\)</span></p>
<p>::: algorithmic
:::
:::</p>
<p>The process of \"relaxing\" an edge is to check if its worth going through the edge <span class="arithmatex">\(\langle u,v \rangle\)</span> which would improve the shortest path from source vertex to some vertex [<code>v</code>]{style="background-color: light-gray"}.</p>
<ul>
<li>Dijkstra's Algorithm relax each edge exactly once.</li>
<li>Bellman-Ford's Algorithm relaxes each edge <span class="arithmatex">\(|V| - 1\)</span> times.</li>
</ul>
<p>For example, assume we have the obtained the following weighted, directed graph and we wanna find the shortest path to vertex <span class="arithmatex">\(D\)</span>. Suppose we start by relaxing the edge <span class="arithmatex">\(\langle C,D \rangle\)</span>.</p>
<p>::: center
<img alt="image" height="3cm" src="../Figure/8/SP/relax2.png" />
:::</p>
<p>Every vertex initially start with a distance of <span class="arithmatex">\(\infty\)</span> and since <span class="arithmatex">\(\infty &gt; 7 + 6 = 13\)</span>, we used the edge <span class="arithmatex">\(\langle C,D \rangle\)</span>. But now let's relax the other edge, <span class="arithmatex">\(\langle B,D \rangle\)</span>.</p>
<p>::: center
<img alt="image" height="3cm" src="../Figure/8/SP/relax3.png" />
:::</p>
<p>Since <span class="arithmatex">\(13 &gt; 6 + 4 = 10\)</span>, we now use the edge <span class="arithmatex">\(\langle B,D \rangle\)</span> instead of <span class="arithmatex">\(\langle C,D \rangle\)</span>.</p>
<h3 id="dijkstras-algorithm">Dijkstra's Algorithm<a class="headerlink" href="#dijkstras-algorithm" title="Permanent link">&para;</a></h3>
<p>As we shall see, Dijkstra's algorithm is pretty similar to Prim's algorithm, which we covered in Minimum Spanning Tree. One limitation of this algorithm is that all edge weights must be non-negative.</p>
<ol>
<li>
<p>Let's pick <span class="arithmatex">\(A\)</span> as our source vertex. There's a table in the right-side, which will use to keep track of distances from the source vertex to each vertex. </p>
<p>::: center
<img alt="image" height="3cm" src="../Figure/8/SP/djk1.png" />
:::</p>
<p>We put infinity for the other vertices as we haven't visited them yet. A change in the distance will be indicated by the grey boxes in each step.</p>
</li>
<li>
<p>Next, we examine the edges leaving <span class="arithmatex">\(A\)</span>. As denoted in  the table, we can reach <span class="arithmatex">\(B\)</span> and <span class="arithmatex">\(C\)</span> with an edge weight of <span class="arithmatex">\(10\)</span> and <span class="arithmatex">\(3\)</span> respectively.</p>
<p>::: center
<img alt="image" height="3cm" src="../Figure/8/SP/djk2.png" />
:::</p>
</li>
<li>
<p>We always pick the smallest edge weight of which the vertex hasn't been discovered. In this case, it's <span class="arithmatex">\(\langle A,C \rangle\)</span>. </p>
<p>::: center
<img alt="image" height="3cm" src="../Figure/8/SP/djk3.png" />
:::</p>
<p>Notice how we don't include the edge <span class="arithmatex">\(\langle A,B \rangle\)</span> in consideration as  <span class="arithmatex">\(B\)</span> is now reachable from <span class="arithmatex">\(\langle A,C \rangle\)</span> and <span class="arithmatex">\(\langle C,B \rangle\)</span> with a smaller total edge weight of <span class="arithmatex">\(7\)</span>.</p>
</li>
<li>
<p>Now <span class="arithmatex">\(D\)</span> and <span class="arithmatex">\(E\)</span> are now reachable. As usual, we'll pick the next smallest edge, which is <span class="arithmatex">\(\langle C, E \rangle\)</span>. </p>
<p>::: center
<img alt="image" height="3cm" src="../Figure/8/SP/djk4.png" />
:::</p>
<p>Similar to what was described before, we don't consider the edge <span class="arithmatex">\(\langle E, D \rangle\)</span>, since <span class="arithmatex">\(D\)</span> has a shortest path using the edge <span class="arithmatex">\(\langle C, D \rangle\)</span> instead of <span class="arithmatex">\(\langle E, D \rangle\)</span>.</p>
</li>
<li>
<p>Our only options left are <span class="arithmatex">\(\langle C,B \rangle\)</span> and <span class="arithmatex">\(\langle C,D \rangle\)</span>. We pick <span class="arithmatex">\(\langle C, B \rangle\)</span>, as it has the smallest edge weight of <span class="arithmatex">\(7\)</span>.</p>
<p>::: center
<img alt="image" height="3cm" src="../Figure/8/SP/djk5.png" />
:::</p>
<p>From <span class="arithmatex">\(A\)</span> to <span class="arithmatex">\(D\)</span>, the edge <span class="arithmatex">\(\langle C, D \rangle\)</span> will results in a distance of <span class="arithmatex">\(11\)</span>, while <span class="arithmatex">\(\langle B,D \rangle\)</span> will result in a distance of <span class="arithmatex">\(9\)</span>. </p>
</li>
<li>
<p>So all that's left is to pick the last remaining edge, which is <span class="arithmatex">\(\langle B, D \rangle\)</span>.</p>
<p>::: center
<img alt="image" height="3cm" src="../Figure/8/SP/djk6.png" />
:::</p>
</li>
<li>
<p>All the edges have been discovered, so we are done with the algorithm.</p>
</li>
</ol>
<h3 id="bellman-fords-algorithm">Bellman-Ford's Algorithm<a class="headerlink" href="#bellman-fords-algorithm" title="Permanent link">&para;</a></h3>
<p>Bellman-Ford's algorithm is more general than Dijkstra's algorithm, such that it can deal with negative edge weights. However, it is a bit more time consuming in comparison.</p>
<ol>
<li>
<p>As usual, let start with vertex <span class="arithmatex">\(A\)</span> as our source vertex and the distances to each vertex listed in the right.</p>
<p>::: center
<img alt="image" height="3cm" src="../Figure/8/SP/djk1.png" />
:::</p>
</li>
<li>
<p>With Bellman-Ford's algorithm, we want to relax all the edges. In other words, we should test out all the possible edges that will result in the shortest path.</p>
</li>
<li>
<p>So this will be our first iteration. Starting at <span class="arithmatex">\(A\)</span>, we can reach <span class="arithmatex">\(B\)</span> and <span class="arithmatex">\(C\)</span> with a weight of <span class="arithmatex">\(10\)</span> and <span class="arithmatex">\(3\)</span>, using the edges, <span class="arithmatex">\(\langle A,B \rangle\)</span> and <span class="arithmatex">\(\langle A,C \rangle\)</span> respectively.</p>
<p>::: center
<img alt="image" height="3cm" src="../Figure/8/SP/bmf1.png" />
:::</p>
</li>
<li>
<p>From <span class="arithmatex">\(B\)</span>, we can reach <span class="arithmatex">\(D\)</span> at a total weight of <span class="arithmatex">\(12\)</span> using the edge  <span class="arithmatex">\(\langle B,D \rangle\)</span>. Note that we won't use the edge <span class="arithmatex">\(\langle B,C \rangle\)</span>, as it result in a longer path from <span class="arithmatex">\(A\)</span> to <span class="arithmatex">\(C\)</span>.</p>
<p>::: center
<img alt="image" height="3cm" src="../Figure/8/SP/bmf2.png" />
:::</p>
</li>
<li>
<p>From <span class="arithmatex">\(C\)</span>, we can reach <span class="arithmatex">\(E\)</span> at a total weight of <span class="arithmatex">\(5\)</span> using the edge <span class="arithmatex">\(\langle C,E \rangle\)</span>. </p>
<p>::: center
<img alt="image" height="3cm" src="../Figure/8/SP/bmf3.png" />
:::</p>
<p>Also, notice if we use the edge <span class="arithmatex">\(\langle C,B \rangle\)</span>, we will get a shorter path to <span class="arithmatex">\(B\)</span> with a total weight of <span class="arithmatex">\(7\)</span>. Consequently, it also lowers the total weight of <span class="arithmatex">\(D\)</span> to <span class="arithmatex">\(9\)</span>.</p>
<p>::: center
<img alt="image" height="3cm" src="../Figure/8/SP/bmf4.png" />
:::</p>
<p>Since we found a better path, we'll remove the edge <span class="arithmatex">\(\langle A,B \rangle\)</span>.</p>
</li>
<li>
<p>From <span class="arithmatex">\(D\)</span>, we only have one edge to work with, which is <span class="arithmatex">\(\langle D,E \rangle\)</span>, however, notice how this increases the total weight of <span class="arithmatex">\(E\)</span> from <span class="arithmatex">\(5\)</span> to <span class="arithmatex">\(16\)</span>, so, we don't use it.</p>
<p>::: center
<img alt="image" height="3cm" src="../Figure/8/SP/bmf5.png" />
:::</p>
</li>
<li>
<p>Similarly for <span class="arithmatex">\(E\)</span>, we have the edge <span class="arithmatex">\(\langle E,D \rangle\)</span>, however, this also increase the weight of <span class="arithmatex">\(D\)</span> by <span class="arithmatex">\(9\)</span> to <span class="arithmatex">\(12\)</span>, so we don't use it.</p>
<p>::: center
<img alt="image" height="3cm" src="../Figure/8/SP/bmf6.png" />
:::</p>
<p>Since we have checked all vertex. we're done with our first iteration.</p>
</li>
<li>
<p>The algorithm at most takes <span class="arithmatex">\(|V| - 1\)</span> iterations to fully obtain the shortest-tree path. However, it can sometimes be less if there's no changes occurring after the next iteration. </p>
</li>
<li>
<p>In our second iteration, we proceed to the do the following, but using the graph we got from our first iteration.</p>
<p>::: center
<img alt="image" height="3cm" src="../Figure/8/SP/bmf7.png" />
:::</p>
<p>Our only option is <span class="arithmatex">\(\langle A,B \rangle\)</span>, however, this doesn't improve the distances of <span class="arithmatex">\(B\)</span>, so we don't update the graph.</p>
</li>
<li>
<p>Same thing can be said for <span class="arithmatex">\(B\)</span>, <span class="arithmatex">\(C\)</span>, <span class="arithmatex">\(D\)</span> and <span class="arithmatex">\(E\)</span>. So after our second iteration, we are finished.</p>
</li>
</ol>
<details class="note">
<summary>Remark</summary>
<p>In the actual exam, they might provide you the edges in which you should relax them by order. The process will still be the same as described from above, but the order may be different, as they might ask you to relax the edges of <span class="arithmatex">\(E\)</span> before <span class="arithmatex">\(D\)</span> or etc.</p>
</details>
<p>One useful property of Bellman-Ford algorithm is that we can also use it to check for the existence of negative cycleone in which the overall sum of the cycle becomes negative.</p>
<p>::: center
<img alt="image" height="3cm" src="../Figure/8/SP/ncycle.png" />
:::</p>
<p>If you add the weights of its edges, it's negative (<span class="arithmatex">\(-6 + 3 + 2 = -1\)</span>). The concept of a shortest path is meaningless if there is a negative cycle, as we'll have a continuous loop. Refer to the example below.</p>
<p>To demonstrate this, let's use the following weighted, directed graph and set <span class="arithmatex">\(A\)</span> as the source vertex. As you can see, we will loop through the cycle <span class="arithmatex">\(B\)</span>, <span class="arithmatex">\(C\)</span>, and <span class="arithmatex">\(D\)</span>, such that total weight keeps decreasing.</p>
<p>::: center
<img alt="image" src="../Figure/8/SP/bmf8.png" width="\textwidth" />
:::</p>
<p>As mentioned before, Bell-man Ford's algorithm runs for <span class="arithmatex">\(|V| - 1\)</span> iterations and it guarantees that at the end, the distances are guaranteed to be correct or [<code>v.d &gt; u.d + w(u,v)</code>]{style="background-color: light-gray"} is false.</p>
<p>::: center
<img alt="image" src="../Figure/8/SP/bmf9.png" width="\textwidth" />
:::</p>
<p>However, as you can see that is not the case, such that [<code>v.d &gt; u.d + w(u,v)</code>]{style="background-color: light-gray"} is still true, thus, it will detect a negative cycle.</p>
<p>As a summary, comparing the two algorithms we've covered in this section:</p>
<ul>
<li>The Dijkstra's algorithm is less time consuming, as it has a time complexity of <span class="arithmatex">\(\text{O}(E\log{V})\)</span>, compared to Bellman-Ford's algorithm which is <span class="arithmatex">\(\text{O}(VE)\)</span>. </li>
<li>Bellman-Ford works when there is negative weight edge, it also detects the negative weight cycle. Dynamic programming approach is taken to implement the algorithm. </li>
<li>While Dijkstra's algorithm doesn't work when there is a negative weight edge. Greedy approach is taken to implement the algorithm.</li>
</ul>

              
            </article>
          </div>
        </div>
        
          <a href="#" class="md-top md-icon" data-md-component="top" data-md-state="hidden">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12Z"/></svg>
            Back to top
          </a>
        
      </main>
      
        <footer class="md-footer">
  
    <nav class="md-footer__inner md-grid" aria-label="Footer">
      
        
        <a href="../../../Term/W2021/" class="md-footer__link md-footer__link--prev" aria-label="Previous: Winter 2021" rel="prev">
          <div class="md-footer__button md-icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
          </div>
          <div class="md-footer__title">
            <div class="md-ellipsis">
              <span class="md-footer__direction">
                Previous
              </span>
              Winter 2021
            </div>
          </div>
        </a>
      
      
        
        <a href="../../MTH314/MTH314/" class="md-footer__link md-footer__link--next" aria-label="Next: MTH314" rel="next">
          <div class="md-footer__title">
            <div class="md-ellipsis">
              <span class="md-footer__direction">
                Next
              </span>
              MTH314
            </div>
          </div>
          <div class="md-footer__button md-icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4Z"/></svg>
          </div>
        </a>
      
    </nav>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
    <div class="md-copyright__highlight">
      Jasper Cruz
    </div>
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
        <div class="md-social">
  
    
    
      
      
    
    <a href="https://github.com/jsprcrz" target="_blank" rel="noopener" title="github.com" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.1.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc.--><path d="M400 32H48C21.5 32 0 53.5 0 80v352c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V80c0-26.5-21.5-48-48-48zM277.3 415.7c-8.4 1.5-11.5-3.7-11.5-8 0-5.4.2-33 .2-55.3 0-15.6-5.2-25.5-11.3-30.7 37-4.1 76-9.2 76-73.1 0-18.2-6.5-27.3-17.1-39 1.7-4.3 7.4-22-1.7-45-13.9-4.3-45.7 17.9-45.7 17.9-13.2-3.7-27.5-5.6-41.6-5.6-14.1 0-28.4 1.9-41.6 5.6 0 0-31.8-22.2-45.7-17.9-9.1 22.9-3.5 40.6-1.7 45-10.6 11.7-15.6 20.8-15.6 39 0 63.6 37.3 69 74.3 73.1-4.8 4.3-9.1 11.7-10.6 22.3-9.5 4.3-33.8 11.7-48.3-13.9-9.1-15.8-25.5-17.1-25.5-17.1-16.2-.2-1.1 10.2-1.1 10.2 10.8 5 18.4 24.2 18.4 24.2 9.7 29.7 56.1 19.7 56.1 19.7 0 13.9.2 36.5.2 40.6 0 4.3-3 9.5-11.5 8-66-22.1-112.2-84.9-112.2-158.3 0-91.8 70.2-161.5 162-161.5S388 165.6 388 257.4c.1 73.4-44.7 136.3-110.7 158.3zm-98.1-61.1c-1.9.4-3.7-.4-3.9-1.7-.2-1.5 1.1-2.8 3-3.2 1.9-.2 3.7.6 3.9 1.9.3 1.3-1 2.6-3 3zm-9.5-.9c0 1.3-1.5 2.4-3.5 2.4-2.2.2-3.7-.9-3.7-2.4 0-1.3 1.5-2.4 3.5-2.4 1.9-.2 3.7.9 3.7 2.4zm-13.7-1.1c-.4 1.3-2.4 1.9-4.1 1.3-1.9-.4-3.2-1.9-2.8-3.2.4-1.3 2.4-1.9 4.1-1.5 2 .6 3.3 2.1 2.8 3.4zm-12.3-5.4c-.9 1.1-2.8.9-4.3-.6-1.5-1.3-1.9-3.2-.9-4.1.9-1.1 2.8-.9 4.3.6 1.3 1.3 1.8 3.3.9 4.1zm-9.1-9.1c-.9.6-2.6 0-3.7-1.5s-1.1-3.2 0-3.9c1.1-.9 2.8-.2 3.7 1.3 1.1 1.5 1.1 3.3 0 4.1zm-6.5-9.7c-.9.9-2.4.4-3.5-.6-1.1-1.3-1.3-2.8-.4-3.5.9-.9 2.4-.4 3.5.6 1.1 1.3 1.3 2.8.4 3.5zm-6.7-7.4c-.4.9-1.7 1.1-2.8.4-1.3-.6-1.9-1.7-1.5-2.6.4-.6 1.5-.9 2.8-.4 1.3.7 1.9 1.8 1.5 2.6z"/></svg>
    </a>
  
    
    
      
      
    
    <a href="https://www.linkedin.com/in/jasper-cruz" target="_blank" rel="noopener" title="www.linkedin.com" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.1.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc.--><path d="M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2 0 38.5 17.3 38.5 38.5 0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9V416z"/></svg>
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    <script id="__config" type="application/json">{"base": "../../..", "features": ["navigation.top", "search.suggest", "search.highlight", "content.tabs.link"], "search": "../../../assets/javascripts/workers/search.2a1c317c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.placeholder": "Search", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version.title": "Select version"}}</script>
    
    
      <script src="../../../assets/javascripts/bundle.6e54b5cd.min.js"></script>
      
        <script src="../../../javascripts/mathjax.js"></script>
      
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      
    
  </body>
</html>